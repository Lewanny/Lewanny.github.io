<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOS-private-API-acquire-and-usage]]></title>
    <url>%2F2018%2F03%2F02%2FiOS-private-API-acquire-and-usage%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[iOS-solution-view-offset-when-calling]]></title>
    <url>%2F2018%2F03%2F02%2FiOS-solution-view-offset-when-calling%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Swift-learn-part2-operator]]></title>
    <url>%2F2018%2F03%2F02%2FSwift-learn-part2-operator%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[iOS-comparison-of-NullSafe-and-AvoidCrash]]></title>
    <url>%2F2018%2F03%2F02%2FiOS-comparison-of-NullSafe-and-AvoidCrash%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[iOS-null-safe-solution]]></title>
    <url>%2F2018%2F03%2F02%2FiOS-null-safe-solution%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Swift-learn-part1-basis]]></title>
    <url>%2F2018%2F03%2F02%2FSwift-learn-part1-basis%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[iOS-build-widget-app-complete-solution]]></title>
    <url>%2F2018%2F03%2F02%2FiOS-build-widget-app-complete-solution%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[iOS-ipa-volume-decrease]]></title>
    <url>%2F2018%2F03%2F02%2FiOS-ipa-volume-decrease%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[iOS-GCD-introduce-and-usage]]></title>
    <url>%2F2018%2F03%2F02%2FiOS-GCD-introduce-and-usage%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[iOS-achive-ipa-package-methods]]></title>
    <url>%2F2018%2F03%2F02%2FiOS-achive-ipa-package-methods%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[iOS-modify-project-name-entirely]]></title>
    <url>%2F2018%2F03%2F02%2FiOS-modify-project-name-entirely%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[CocoaPods 的安装使用和常见问题]]></title>
    <url>%2F2018%2F03%2F02%2FiOS-CocoaPods-usage-and-problem%2F</url>
    <content type="text"><![CDATA[CocoaPods 是一个负责管理 iOS 项目中第三方开源库的工具，iOS 开发不可避免地要使用第三方开源库，CocoaPods 的出现使得我们可以节省设置和更新第三方开源库的时间，下面将介绍如何安装使用 CocoaPods 以及一些常见问题的解决方案。 CocoaPods 安装步骤Ruby 环境搭建CocoaPods 是用 Ruby 写的，使用 CocoaPods 需要 Ruby 环境，Mac OS 本身自带 Ruby，但最好还是更新一下，因为升级了系统之后，可能会出现一些意想不到的情况，首先打开终端 Terminal 。 查看下当前ruby版本： ruby -v 。 升级ruby： sudo gem update —system 。 由于国内防火墙限制我们，可以用淘宝的Ruby镜像来访问CocoaPods。终端输入如下命令： 123gem sources –remove https://rubygems.org/ 。gem sources -a https://ruby.taobao.org/ 。gem sources -l （用来检查使用替换镜像位置成功）。 下载安装 CocoaPods 命令： sudo gem install cocoapods，Mac OS 10.11 以上系统使用命令： sudo gem install -n /usr/local/bin cocoapods。 使用搜索命令 pod search AFNetworking 查找某一个库，看 CocoaPods 有没有安装好，如下便安装成功。 CocoaPods的使用进入到工程根目录打开项目所在的文件夹，在终端敲入 cd Desktop/CocoaPodsText 或将文件夹拖拽到终端，进入到项目所在文件夹（根目录）。 建立 Podfile (配置文件) 终端输入： vim Podfile 。 接着输入： i 进入 insert 模式。 内容按这个格式输入：12345target ‘YourProjectName’ do pod ‘MBProgressHUD’ pod ‘ASIHTTPRequest’, ‘~&gt; 1.8.2’ pod ‘SDWebImage’, ‘~&gt; 3.7.3’end 如果你不知道这些框架目前的版本是，可以使用命令 pod search + 框架名称 查看相应的信息，不写版本默认为框架的最新版本。 然后按 Esc ，并且输入 shift + ：号进入 vim 命令模式，然后在冒号后边输入 wq ，按回车键，保存并且退出，完成后会发现对应项目根目录中多一个 Podfile 文件。 Podfile 文件的创建编辑可以使用终端操作，也可直接创建文件打开文件编辑。 安装第三方类库终端 cd 到项目根目录小，然后输入 pod install，等待一会，框架就自动安装好了，如图所示，多出了4个文件夹/文件夹。 注意：现在打开项目不是点击 podTest.xodeproj 了，而是点击 podsTest.xcworkspace (白的图标)。 常用命令 pod install –no-repo-update –verbose 关掉索引更新并安装且体现下载过程。 pod install –no-repo-update —verbose 同为需要添加删除时。 pod update –no-repo-update —verbose 更新 pod (更新第三方库时)。 pod —-version 查看当前 pod 版本。 sudo gem uninstall cocoapods （卸载当前的CocoaPods）。 sudo gem install cocoapods -v 0.38.1 （安装 0.38.1 版本的 CocoaPods ）。 关于 CocoaPods 的一些问题总结出现导入头文件问题，未找到 xxx.h Xcode 选择 Target -&gt; Build Settings 菜单，找到 User Header Search Paths 设置项。 新增一个值 ${SRCROOT}，并且选择为 Recursive。 图形化插件 终端中执行： curl -fsSL https://raw.github.com/supermarin/Alcatraz/master/Scripts/install.sh | sh 。 安装完成重启 Xcode 即可， 在 Xcode -&gt; window -&gt; package manger 可以找到 CocoaPods 选项，使用起来简单方便。（Xcode8 导致所有插件失效） 如何编译从 github 上 checkout 下来的一个已包含 CocoPods 类库的项目 删除工程文件夹下的 Podfile、Podfile.lock 及 Pods 文件夹。 删除 xcworkspace 文件。 使用 xcodeproj 文件打开工程，删除 Frameworks 组下的 Pods.xcconfig 及 libPods.a 引用。 在工程设置中的 Build Phases 下删除 Check Pods Manifest.lock 及 Copy Pods Resources 。 安装 CocoaPods 时出现错误ERROR: While executing gem ... (Errno::EPERM) Operation not permitted - /usr/bin/pod 执行 sudo gem install -n /usr/local/bin cocoapods 即可解决。 Mac OS 升级到 10.11 后当 pod 命令失效报错：-bash: pod: command not found。这是你之前有 CocoaPods，但是输入比如 pod update 或者 pod install 之后命令失效，输入：sudo gem install -n /usr/local/bin cocoapods然后在执行命令，就会解决。 执行 pod update 和 pod install 速度比较慢的问题在国内，你有可能就被墙了，所以就不要用 pod update 和 pod install 了，使用：pod update –verbose –no-repo-update 和 pod install –verbose –no-repo-update 来代替。 报错：[!] Unable to add a source with url https//: github.com/CocoaPods/Spece.git named master 如果你是初次初次使用CocoaPods， 可能会出现 Setting up CocoaPods master repo 的提示， 说明 CocoaPods 在将它的信息下载到你的电脑 ~/.cocoapods 里，使用 cd ~/.cocoapods 到该目录里，用 du -sh * 命令来查看文件大小，每隔几分钟查看一次，我的这个目录最终大小是 123M ，就是完成了。 上面的错误就是因为你本地 repo 的问题，你可以尝试使用 pod update 更新，或者可以到网上下载 master 放到 ~/.cocoapods 里面即可。 打开本地目录 ~/.cocoapods，可以看到里面存放的是所有库的podspec 文件，这里面包含了所有可以使用 CocoaPods 管理库的版本和地址等信息，关于 podspec 文件可参考我的另一篇文章 ”使用CocoaPods 制作和关联使用私有库“ 报错： [!] The dependency XXX is not used in any concrete target.需要在 Podfile 文件中指定 target 工程，未指定便会报这个错。12345target 'FMGApp' do pod 'JazzHands' pod 'SSKeychain', '1.2.3' pod 'UMengSocial', '4.2.3'end 持续更新中…]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>CocoaPods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Next 主题的优化]]></title>
    <url>%2F2018%2F02%2F28%2F2018%2FHexo-next-theme-optimization%2F</url>
    <content type="text"><![CDATA[关于 Next 主题的优化，如设置主题样式、字体、头像、第三方统计、评论、分享等在 NexT 使用文档 里都有极详细的介绍，这里不一一介绍了。只记录一些文档中没有提及的点。 第三方推荐搜索：Local Search 简单方便，安装即可使用。统计：不蒜子统计，简单易用推荐使用。评论：来必力评论，目前好像也只有这个可用了，之前还用过多说评论和网易云跟帖。 侧边栏社交小图标设置打开主题配置文件 _config.yml 搜索 social:，在 图标库 找自己喜欢的小图标，并将名字复制在对应的 || 后，保存即可： 1234social: GitHub: https://github.com/Lewanny || github 微博: https://weibo.com/u/2951067307 || weibo 简书: https://www.jianshu.com/users/f0040a970739 || heartbeat 添加 about 页面进入到博客根目录下，执行以下命令： $ hexo new page &quot;about&quot; 完成后会在 /source/about 目录下生成一个 index.md 文件。打开 index.md 文件，在 data 下添加 type: &quot;about&quot;，然后编辑自己想要展示的内容即可。（注意将主题配置文件中的 menu: about 页面打开）。 添加网易云音乐播放使用 iframe 标签播放即可。 &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; width=&quot;300&quot; height=&quot;86&quot; src=&quot;https://music.163.com/outchain/player?type=2&amp;id=5253801&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt; // 到网易云中复制即可 如果想放在侧栏里面播放，将代码 加入到 hexo/themes/next/layout/_macro 目录中的 sidebar.swig 文件中即可。位置如下： 设置网站的 Favicon 图标准备一个常见格式名(如.jpg、.png等)的图片作为备选 favicon，选择一个 favicon 制作网站完成制作，例如：比特虫。 如下修改主题配置文件即可：12345favicon: small: /images/favicon_16x16.ico medium: /images/favicon_32x32.ico apple_touch_icon: /images/favicon_128x128.ico safari_pinned_tab: /images/favicon_128x128.ico 添加 “high 一下”绑定独立域名购买域名在你的域名注册提供商那里配置DNS解析，获取GitHub的IP地址点击，进入source目录下，添加CNAME文件 $ cd source/ $ touch CNAME $ vim CNAME # 输入你的域名 $ git add CNAME $ git commit -m &quot;add CNAME&quot; ####]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>主题优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Hexo 搭建个人博客并部署到 Github Page]]></title>
    <url>%2F2018%2F02%2F26%2F2018%2FHexo-build-yourown-blog-with-hexo%2F</url>
    <content type="text"><![CDATA[Hexo 是一个快速、简洁且高效的博客框架。而 Github 是一个免费的代码托管工具，利用 Github Page 可以免费创建一个静态网站。下面将介绍如何使用 Hexo 和 Github，在 mac 环境下搭建静态博客。 由于前段时间电脑突然故障，导致所有本地数据全部丢失，所以不得不重新把个人博客搭起来。还好当时把博客分别部署到了 Coding 和 Github，省去了一些麻烦事，只是 md 文件都要重新写一遍了。这里记录下相关的过程。有备无患。 Hexo 环境配置Node.js用来生成静态页面，可到 Node.js 官网 下载推荐版本，默认配置一路安装即可。 Git用来将本地 Hexo 内容提交到 Github 上。Xcode 自带 Git。如果没有 Xcode 可以参考 Git 官网 下载安装。 安装 HexoNode.js 和 Git 都安装好后就可以正式安装 Hexo 了，终端执行如下命令： $ sudo npm install -g hexo sudo:linux 系统管理指令 -g:全局安装 初始化 Hexo，终端 cd 到一个你选定的目录，执行 hexo init 命令： $ hexo init blog blog 是你建立的文件夹名称。 cd 到 blog 文件夹下，执行如下命令，安装 npm： $ npm install 执行如下命令，开启 Hexo 服务器（结束为 control+c）： $ hexo s 此时，浏览器中打开网址 http://localhost:4000，如果能看到如下页面，Hexo 本地初始化即完成： 关联到 Github添加 ssh key 到 Github检查 SSH keys 是否存在 Github执行如下命令，检查 SSH keys 是否存在。如果有文件 id_rsa.pub 或 id_dsa.pub ，则直接进入步骤 1.3 将 SSH key 添加到 Github 中，否则进入下一步生成 SSH key。 $ ls -al ~/.ssh 生成新的 ssh key执行如下命令生成 public/private rsa key pair，注意将 your_email@example.com 换成你自己注册 Github 的邮箱地址。、 $ ssh-keygen -t rsa -C &quot;your_email@example.com&quot; 接下来会提示输入密码路径，按 3 次回车，密码为空。最后会在相应路径下（~/.ssh/id_rsa.pub）生成 d_rsa 和 id_rsa.pub 两个文件。 将 ssh key 添加到 Github 中Finder 前往文件夹 ~/.ssh/id_rsa.pub 打开 id_rsa.pub 文件，里面的信息即为 SSH key，将这些信息复制到 Github 的 Add SSH key 页面即可。 进入Github –&gt; Settings –&gt; SSH keys –&gt; add SSH key，Title 任意，将复制的内容粘贴到 Key 里，点击 Add key 按钮即可。 创建仓库登录 Github 帐号，新建仓库，命名必须为 用户名.github.io 固定写法，如Lewanny.github.io,如下图所示： 本地的 blog 文件夹下内容为： 配置文件打开 _config.yml 文件，里面是博客的主体配置项，找到 deploy: 配置，修改如下：1234deploy: type: git repository: https://github.com/Lewanny/Lewanny.github.io.git branch: master 注意：在配置所有的 _config.yml 文件时（包括 theme）时，在所有的冒号 : 后边都要加一个空格，否则执行 hexo 命令会报错。 部署文件生成静态页面命令在 blog 文件夹目录下执行生成静态页面命令： $ hexo g // 或者：hexo generate 此时若出现如下报错：1 ERROR Local hexo not found in ~/blog 2 ERROR Try runing: &#39;npm install hexo --save&#39;则执行命令：npm install hexo --save 配置命令再执行配置命令： $ hexo d // 或者：hexo deploy 若执行命令 hexo deploy 仍然报错：ERROR Deployer not found: git。则执行如下命令来安装 hexo-deployer-git： npm install --save hexo-deployer-git 再次执行 hexo generate 和 hexo deploy 命令 (或 hexo d -g，即部署前先生成静态界面) 即可完成 Github 关联。此时，浏览器中打开网址 https://lewanny.github.io（注意将 username 替换）能看到和打开 http://localhost:4000 时一样的页面。 安装 Theme可以到 Hexo 官网主题页 去搜寻自己喜欢的 theme。这里以 hexo-theme-next 为例，Next 官网。 终端 cd 到 blog 目录下执行如下命令： $ git clone https://github.com/iissnan/hexo-theme-next themes/next 将 blog 目录下 _config.yml 里 theme 的名称 landscape 修改为 next 即可。 终端 cd 到 blog 目录下执行如下命令(每次部署文章的步骤)：12$ hexo clean // 清除缓存文件 (db.json) 和已生成的静态文件 (public)$ hexo d -g // 生成缓存和静态文件并重新部署到服务器 至于更改 theme 内容，比如名称，描述，头像等去修改 blog/_config.yml 文件和 blog/themes/next/_config.yml 文件中对应的属性名称即可， 不要忘记冒号:后加空格。NexT 使用文档里有极详细的介绍。 发表文章终端 cd 到 blog 文件夹下，执行如下命令新建文章： hexo new &quot;postName&quot; // postName为文章名字 名为 postName.md 的文件会建在目录 /blog/source/_posts 下。你当然可以用 vim 来编辑文章，这里推荐使用 MacDown。 文章编辑完成后，终端 cd 到 blog 文件夹下，执行如下命令来发布：12hexo generate // 生成静态页面hexo deploy // 将文章部署到 Github // 或 hexo d -g 至此，使用 Hexo 搭建个人博客并部署到 GitHub 就基本完成了。后面会陆续更新出如何绑定独立域名、next 主题的优化和功能配置、同时部署博客到 GitHub 和 Coding、提交文章到百度谷歌收录、备份博客等（防止悲剧重演…）。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 3D Touch 功能的介绍和实现]]></title>
    <url>%2F2015%2F12%2F11%2F2015%2FiOS-3DTouch-introduction-and-realization%2F</url>
    <content type="text"><![CDATA[3D Touch 是苹果在 2015 年秋季发布会上发布的 iPhone 6S 的新功能，除了类似 Apple Watch、MacBook 触摸板的标准、深压体验之外， iPhone 6s 的触摸屏还将新增一种新层次的维度，实现更多操作体验。 3D Touch 是什么3D Touch 的具体功能3D Touch 是一种可以让你与手机进行互动的全新方式。新的 iPhone 6S 能够感应你按压屏幕的力度。除了轻点、轻扫、双指开合这些熟悉的 Multi‑Touch 手势之外，3D Touch 还带来 Peek 和 Pop，且当你使用 3D Touch 时，iPhone 将回以轻微的触感，让你不仅能够看到按下屏幕的操作效果，还能感觉得到。 具体功能是，用力按一个图标会弹出一层半透明菜单，里面包含了该应用下的一些快捷操作，看起来类似 PC 上的右键。3D Touch 的功能很强大，Peek 和 Pop 让你能够预览所有类型的内容，甚至可对内容进行操作，却不必真的打开它们。例如轻点电话就可以查看最近联系人，按压相机可以快速自拍，按压图片库可以快速浏览大图等。 开发环境和调试设备Apple 不仅推出了 3D Touch 功能，还开放其 API 的调用接口。 开发环境：Xcode7 或以上版本。 调试设备：iOS9 或以上系统版本，iPhone6s 或以上设备。 主要功能模块3D Touch 功能主要分为两大块： 主屏幕 Icon 上的快捷标签。（Home Screen Quick Actions Peek（预览）和 Pop （跳至预览的详细界面） 3D Touch 的实现如何让你的模拟器支持 3D Touch3D Touch的必要条件是 iPhone 6s 或以上、iOS 9 或以上、 Xcode 7 或以上版本，没有 iPhone 6s 的话也没关系，github 上有人提供了这样的一个可以让我们在模拟器上进行 3D Touch 的效果测试的插件，安装和使用方法参见 git 主页里的介绍。SBShortcutMenuSimulator 如何判断设备是否支持 3D Touch123if (self.traitCollection.forceTouchCapability == UIForceTouchCapabilityAvailable) &#123; // 支持 3D Touch&#125; 不能使用判断手机是否为 6S 或 6SP，是因为如果用户在设置 -&gt; 通用 -&gt; 3D Touch 中将该功能关闭的话，同样 forceTouch 是不可用的。另外可在 traitCollectionDidChange: 代理中监听 forceTouchCapability 的变化。 主屏幕按压应用图标展示快捷选项（即 Home Screen Quick Actions）一个应用最多可以有 4 个快捷选项标签，iOS 9 为我们提供了 2 种方式来开发按压应用图标展示快捷选项功能（Home Screen Quick Actions），即动态标签和静态标签。 静态标签在 info.plist 文件中手动加入 UIApplicationShortcutItems 选项。 UIApplicationShortcutItems：数组中的每个元素就是每一个快捷选项标签（最多 4 个）。 UIApplicationShortcutItemTitle：标签的标题（必填） UIApplicationShortcutItemType：标签的唯一标识，用作区分（必填） UIApplicationShortcutItemIconType：标签系统图标的类型，如搜索、定位、分享等，详见 enum UIApplicationShortcutIconType（选填） UIApplicationShortcutItemIconFile：自定义标签图片（可选） UIApplicationShortcutItemSubtitle：标签的副标题（可选） UIApplicationShortcutItemUserInfo：字典信息，可用于传值等（可选） 动态标签在 AppDelegate.m 文件中调用如下方法：1234567891011121314//创建应用图标上的3D touch快捷选项- (void)creatShortcutItem &#123; //创建系统风格的icon UIApplicationShortcutIcon *icon = [UIApplicationShortcutIcon iconWithType:UIApplicationShortcutIconTypeShare]; // 创建自定义图标的icon // UIApplicationShortcutIcon *icon2 = [UIApplicationShortcutIcon iconWithTemplateImageName:@"分享.png"]; //创建快捷选项 UIApplicationShortcutItem * item = [[UIApplicationShortcutItem alloc]initWithType:@"com.mycompany.myapp.share" localizedTitle:@"分享" localizedSubtitle:@"分享副标题" icon:icon userInfo:@&#123;@"key2" : @"value2"&#125;]; //添加到快捷选项数组 [UIApplication sharedApplication].shortcutItems = @[item];&#125; 点击快捷选项标签进入应用的响应主屏幕 icon 上的快捷标签点击进入页面的实现有点类似消息通知的实现方式，需要增加两处代码：首次启动 App （杀死后）和 App 从后台进入到前台启动（未被杀死）。 首次启动的响应：12345678910111213141516171819202122232425262728293031323334353637// App 首次启动的响应方法- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; MainViewController *mainView = [[MainViewController alloc] init]; UINavigationController *mainNavi = [[UINavigationController alloc] initWithRootViewController:mainView]; self.window.rootViewController = mainNavi; [self.window makeKeyAndVisible]; //创建应用图标上的3D touch快捷选项 [self creatShortcutItem]; UIApplicationShortcutItem *shortcutItem = [launchOptions valueForKey:UIApplicationLaunchOptionsShortcutItemKey]; // 如果是从快捷选项标签启动 App，则根据不同标识执行不同操作，然后返回 NO，防止调用 // - (void)application:(UIApplication *)application performActionForShortcutItem:(UIApplicationShortcutItem *)shortcutItem completionHandler:(void (^)(BOOL))completionHandler if (shortcutItem) &#123; //判断设置的快捷选项标签唯一标识，根据不同标识执行不同操作 if([shortcutItem.type isEqualToString:@"com.lewanny.button"])&#123; // 点击第一个按钮 NSLog(@"点击了 -&gt; 第一个按钮"); &#125; else if ([shortcutItem.type isEqualToString:@"com.lewanny.search"]) &#123; // 进入搜索界面 NSLog(@"点击了 -&gt; 搜索按钮"); &#125; else if ([shortcutItem.type isEqualToString:@"com.lewanny.location"]) &#123; // 进入定位界面 NSLog(@"点击了 -&gt; 定位按钮"); &#125;else if ([shortcutItem.type isEqualToString:@"com.lewanny.share"]) &#123; // 进入分享页面 NSLog(@"点击了 -&gt; 分享按钮"); &#125; return NO; &#125; return YES;&#125; 后台启动的响应：123456789101112131415161718192021222324// 如果 App 没被杀死，点开 Touch 后台启动会调用该代理方法- (void)application:(UIApplication *)application performActionForShortcutItem:(UIApplicationShortcutItem *)shortcutItem completionHandler:(void (^)(BOOL))completionHandler &#123; if (shortcutItem) &#123; //判断设置的快捷选项标签唯一标识，根据不同标识执行不同操作 if([shortcutItem.type isEqualToString:@"com.lewanny.button"])&#123; // 点击第一个按钮 NSLog(@"点击了 -&gt; 第一个按钮"); &#125; else if ([shortcutItem.type isEqualToString:@"com.lewanny.search"]) &#123; // 进入搜索界面 NSLog(@"点击了 -&gt; 搜索按钮"); &#125; else if ([shortcutItem.type isEqualToString:@"com.lewanny.location"]) &#123; // 进入定位界面 NSLog(@"点击了 -&gt; 定位按钮"); &#125;else if ([shortcutItem.type isEqualToString:@"com.lewanny.share"]) &#123; // 进入分享页面 NSLog(@"点击了 -&gt; 分享按钮"); &#125; &#125; if (completionHandler) &#123; completionHandler(YES); &#125;&#125; peek（展示预览）和 pop（跳页至预览的界面）的实现peek：当你用力按下屏幕按到一定程度时，系统会弹出一个预览视图，这个过程就称之为 peek。pop：再用力按下去就会展开到预览视图的控制器，这过程就是 pop 。 注册 peek 和 pop首先给 view 注册 3DTouch 的 peek 和 pop 功能。（在需要使用该功能的个页面上注册）1234567// 注册 3D Touch，先判断是否可用if (self.traitCollection.forceTouchCapability == UIForceTouchCapabilityAvailable)&#123; [self registerForPreviewingWithDelegate:self sourceView:self.locationView]; NSLog(@"3D Touch 可用"); &#125;else&#123; NSLog(@"3D Touch 无效");&#125; 继承协议需要继承协议 UIViewControllerPreviewingDelegate 。 代理方法实现 UIViewControllerPreviewingDelegate 的代理方法。123456789101112131415161718192021222324252627// peek 手势弹出的预览视图// previewingContext: 执行 peek 的上下文对象。// location: 按压位置再 souceView 上的点，可以理解为手指在屏幕上的按压点。- (nullable UIViewController *)previewingContext:(id&lt;UIViewControllerPreviewing&gt;)previewingContext viewControllerForLocation:(CGPoint)location &#123; // 获取sourceView 即注册时传入的sourceView，一般为控制器的view UIView *pressView = [previewingContext sourceView]; // 然后判断按压点是否在某个控件的 frame 内， /* 这里有个涉及到坐标系转换的细节问题 如果self.locationView不是sourceView的直接子控件，那么我们需要把point转换到self.locationView的父控件的坐标系中，代码如下： point = [self.locationView.superView convertPoint:point fromView:sourceView]; 若缺少这段代码，你会发现按压位置错乱的bug。 */ // 如果 self.locationView.frame 不包含这个点就直接 return, 不做任何操作 if(!CGRectContainsPoint(self.locationView.frame, location)) return nil; // 否则即触摸点在 self.locationView 上，设置 sourceRect，这个 souceRect 就是当你按压售后浮起来的那个矩形区域，即不被虚化的范围。 CGRect sourceRect = self.locationView.frame; [previewingContext setSourceRect:sourceRect]; // 返回预览界面 TouchViewController *touchVc = [[TouchViewController alloc] init]; return touchVc;&#125; 123456// pop 过程会调用此方法，执行跳转- (void)previewingContext:(id&lt;UIViewControllerPreviewing&gt;)previewingContext commitViewController:(UIViewController *)viewControllerToCommit &#123; // Show 要展示的视图 [self showViewController:viewControllerToCommit sender:self];&#125; 设置预览视图在接下来的预览视图中添加向上滑显示的菜单，即 TouchViewController 的 .m 文件中自定义你要显示的菜单。123456789101112131415161718// 3D Touch 上移显示的视图-(NSArray&lt;id&lt;UIPreviewActionItem&gt;&gt; *)previewActionItems&#123; UIPreviewAction *action1 = [UIPreviewAction actionWithTitle:@"菜单_01" style:UIPreviewActionStyleDefault handler:^(UIPreviewAction * _Nonnull action, UIViewController * _Nonnull previewViewController) &#123; NSLog(@"click -&gt; 菜单_01"); &#125;]; UIPreviewAction *action2 = [UIPreviewAction actionWithTitle:@"菜单_02" style:UIPreviewActionStyleDefault handler:^(UIPreviewAction * _Nonnull action, UIViewController * _Nonnull previewViewController) &#123; NSLog(@"click -&gt; 菜单_02"); &#125;]; UIPreviewAction *action3 = [UIPreviewAction actionWithTitle:@"菜单_03" style:UIPreviewActionStyleDefault handler:^(UIPreviewAction * _Nonnull action, UIViewController * _Nonnull previewViewController) &#123; NSLog(@"click -&gt; 菜单_03"); &#125;]; // 想要显示多个就定义多个 UIPreviewAction NSArray *actions = @[action1,action2,action3]; return actions;&#125; Tableview 中使用 peek 和 pop123456789101112131415161718192021222324252627- (nullable UIViewController *)previewingContext:(id&lt;UIViewControllerPreviewing&gt;)previewingContext viewControllerForLocation:(CGPoint)location &#123; // 获取 sourceView UIView *sourceView = [previewingContext sourceView]; // 通过坐标点获取 indexPath /* 同样如果sourceView != self.tableView的话，也需要转换坐标系 point = [self.tableView convertPoint:point fromView:sourceView]; */ NSIndexPath*indexPath = [self.tableView indexPathForRowAtPoint:location]; // 如果 indexPath 为 nil，则直接返回 nil if(!indexPath) return nil; // 获得当前cell，设置sourceRect UITableViewCell *cell = [self.tableView cellForRowAtIndexPath:indexPath]; CGRect sourceRect = cell.frame; /* 这里同时也涉及到坐标系转换 sourceRect = [self.tableView convertRect:cell.frame toView:sourceView]; */ [previewingContext setSourceRect:sourceRect]; // 返回预览界面 TouchViewController *touchVc = [[TouchViewController alloc] init]; return touchVc;&#125; 3D Touch 压力值的运用直接在需要的 ViewController 的 .m 文件中加入以下方法即可，按压 controller 中的任何视图都会调用这个方法：1234567// 按住移动或压力值改变时的回调-(void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; NSArray *arrayTouch = [touches allObjects]; UITouch *touch = (UITouch *)[arrayTouch lastObject]; // 注意：如果按压的是 UILabel 或 UIImageView，要将其的 userInteractionEnabled 属性设置为YES NSLog(@"move压力 ＝ %f",touch.force);&#125;]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>3D Touch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 上传 ipa 包至 App Store 报错 Error ITMS-90096 Your binary is not optimized for iPhone 5]]></title>
    <url>%2F2015%2F11%2F06%2F2015%2FiOS-upload-appstore-error-90096-solution%2F</url>
    <content type="text"><![CDATA[问题描述向 App Store 提交 ipa 包时报如下错误: 使用 Xcode7 向 App Stor e提交 ipa 包时，提示 ERROR ITMS-90096：”You binary is not optimized for iPhone 5….” 错误。 解决方案解决方案在于对 iPhone5 单独设置 LaunchImage 图片: 把对应的图片放在工程的根目录下。 图片的尺寸需保证为 320*568 大小。 图片的命名为 Default-568.png 。 以上三点为必要条件，然后在工程的 plist 文件中添加 UILaunchimages 数组即可，如下图：]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>AppStore 上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 判断系统版本号的多种方法]]></title>
    <url>%2F2015%2F10%2F04%2F2015%2FiOS-judge-system-version-methods%2F</url>
    <content type="text"><![CDATA[iOS 开发中，有一些启用掉的 API 运行在高版本的系统上可能会无效等问题，在低版本系统上使用新的 API 也是如此，甚至会引起程序的 Crash 。所以此时就需要判断用户设备的版本，根据不同的版本号使用对应的方法来适配不同的系统。 例如以下 NSCalendar 的方法：1234// iOS 8 之前是使用这个方法 currentCalendar 来获取 NSCalendar 对象，如果在 iOS 8 或 iOS 9 上使用就可能会有问题。NSCalendar *calendar = [NSCalendar currentCalendar]; // iOS 8 以后，可以使用下面的方法获取 NSCalendar 对象。NSCalendar *calendar = [NSCalendar calendarWithIdentifier:NSCalendarIdentifierGregorian]; 比较系统版本号获取当前系统版本：1NSString *version = [UIDevice currentDevice].systemVersion; 将版本号 String 转换成 Double 进行比较：12345678NSCalendar *calendar = nil;if (version.doubleValue &gt;= 8.0) &#123; // iOS 系统版本 &gt;= 8.0 calendar = [NSCalendar calendarWithIdentifier:NSCalendarIdentifierGregorian];&#125; else&#123; // iOS 系统版本 &gt; 8.0 calendar = [NSCalendar currentCalendar]; &#125; 比较 Foundation 框架的版本号iOS 系统版本号提升的时候，Foundation 的版本也会同时提高。12345678910111213141516171819202122232425#if TARGET_OS_IPHONE#define NSFoundationVersionNumber_iPhoneOS_2_0 678.24#define NSFoundationVersionNumber_iPhoneOS_2_1 678.26#define NSFoundationVersionNumber_iPhoneOS_2_2 678.29#define NSFoundationVersionNumber_iPhoneOS_3_0 678.47#define NSFoundationVersionNumber_iPhoneOS_3_1 678.51#define NSFoundationVersionNumber_iPhoneOS_3_2 678.60#define NSFoundationVersionNumber_iOS_4_0 751.32#define NSFoundationVersionNumber_iOS_4_1 751.37#define NSFoundationVersionNumber_iOS_4_2 751.49#define NSFoundationVersionNumber_iOS_4_3 751.49#define NSFoundationVersionNumber_iOS_5_0 881.00#define NSFoundationVersionNumber_iOS_5_1 890.10#define NSFoundationVersionNumber_iOS_6_0 992.00#define NSFoundationVersionNumber_iOS_6_1 993.00#define NSFoundationVersionNumber_iOS_7_0 1047.20#define NSFoundationVersionNumber_iOS_7_1 1047.25#define NSFoundationVersionNumber_iOS_8_0 1140.11#define NSFoundationVersionNumber_iOS_8_1 1141.1#define NSFoundationVersionNumber_iOS_8_2 1142.14#define NSFoundationVersionNumber_iOS_8_3 1144.17#define NSFoundationVersionNumber_iOS_8_4 1144.17#define NSFoundationVersionNumber_iOS_8_x_Max 1199#define NSFoundationVersionNumber_iOS_9_0 1240.1#endif 123456if (NSFoundationVersionNumber &gt;= NSFoundationVersionNumber_iOS_8_0) &#123; // iOS 系统版本 &gt;= 8.0 calendar = [NSCalendar calendarWithIdentifier:NSCalendarIdentifierGregorian];&#125; else &#123; calendar = [NSCalendar currentCalendar]; &#125; 通过特定的类来判断例如 UIAlertController 是 iOS 8 以后才有的类：NS_CLASS_AVAILABLE_IOS(8_0)可以通过判断 NSClassFromString(@&quot;UIAlertController&quot;) 是否为 NULL 对象，从而来判断当前系统版本是否大于 8.0 。12NSLog(@"%@,%@",NSClassFromString(@"UIAlertController"), NSClassFromString(@"CustomClass"));打印结果：UIAlertController---UIAlertController, CustomClass---(null) 1234// iOS 系统版本 &gt;= 8.0if (NSClassFromString(@"UIAlertController")) &#123; // do something&#125; 通过特定方法进行判断NS_AVAILABLE(10_10, 8_0)：意为此方法是 iOS 8 之后才出现的，例如下面 NSString 的方法：1- (BOOL)containsString:(NSString *)str NS_AVAILABLE(10_10, 8_0); 123if ([@"" respondsToSelector:@selector(containsString:)]) &#123; // iOS系统版本 &gt;= 8.0&#125;]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>版本号</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 中 Block 的基本语法和使用]]></title>
    <url>%2F2015%2F09%2F24%2F2015%2FiOS-block-basic-grammar-and-usage%2F</url>
    <content type="text"><![CDATA[代码块 Block 是苹果在 iOS4 开始引入的对 C 语言的扩展，用来实现匿名函数的特性。Block 是一种特殊的数据类型，其可以正常定义变量、作为参数、作为返回值。特殊地，Block 还可以保存一段代码，在需要的时候调用。目前 Block 已经广泛应用于 iOS 开发中，常用于 GCD、动画、排序及各类回调。 Block 在我们的实际开发中太常用了，个人觉得很好用，无论是界面传值还是当做参数都十分的灵活。例如 GCD、AFNetworking 的回调等都是用 Block 实现的，且 Apple 官方的很多 API 都由 Delegate 写法换成了 Block 。 Block 是什么？那么，Block 到底是什么呢？用一句话来概括就是带有自动变量的匿名函数。 匿名函数匿名函数顾名思义就是不带名字的函数，C 语言中不允许该类函数的存在，而在 OC 的 Block 中则是可以使用指针来直接调用一个函数的。 自动变量自动变量在 Block 中的具体表现就是截获自动变量。1234567int a = 0;void(^blockLog)() = ^&#123; NSLog(@"Input a = %d", a);&#125;;a = 10;blockLog();// 打印结果：Input a = 0 上面的代码虽然我们在调用 blockLog 前改变了变量 a 的值，但是输出的值还是 blockLog 在编译时 a 的值。所以截获自动变量的概念就是：在Block中会保存变量的值，而不会随变量的值的改变而改变。 我们再来看下面的代码。12345int a = 0;void(^blockLog)() = ^&#123; a = 10; NSLog(@"Input a = %d", a);&#125;; 上面的代码会报错，编译器会提示不能再 Block 中改变变量的值。因为在 Block 截获了变量的瞬间值后就不能再改变改变量的值，如果想在 Block 中改变该变量的值，那么我们需要在变量声明的时候加上 __Block 修饰符。如下：1234567__block int a = 0;void(^blockLog)() = ^&#123; a = 10; NSLog(@"Input a = %d", a);&#125;;blockLog();// 打印结果：Input a = 10 但是下面的情况是允许的：123456NSMutableArray *arrayInsert = [NSMutableArray array];void(^blockLog)() = ^&#123; [arrayInsert addObject:@"Obj"]; NSLog(@"array = %@", arrayInsert);&#125;;blockLog(); 因为我们只是对截获的变量进行了操作，而没有进行赋值，所以对于截获变量，可以进行操作而不可以进行赋值。 还有一点需要注意，在 Block 中不支持对 C 语言数组进行操作。 Block 的语法和分类Block 的语法下面是一个完整的 Block 写法：123^int (NSString *str1, NSString *str2) &#123; return [str1 intValue] + [str2 intValue];&#125; “^” 这个符号用来表示这是一个 Block 。 int 表示返回值。（可省略或 void） (NSString str1, NSString str2) 这个括号中是 Block 的参数，即参数列表，语法和 C 语言类似。（没有时也可省略） Block 变量那么为什么需要 Block 变量？我们可以这样理解，我们可以通过这个 Block 变量来获取 Block 的指针，然后通过这个指针就可以来使用 Block 函数。我们先来看一下如何声明一个 Block 变量：1int (^blockExp)(NSString *str1,NSString *str1); 对照前面的 Block 函数其含义分别为： 返回值 变量名 参数列表 然后我们用上面讲到的 Block 语法来对这 Block 变量进行赋值，我们就可以将这个 Block 变量当作 C 语言函数来使用了。 123456int (^blockExp)(NSString *str1, NSString *str2);blockExp = ^(NSString *str1, NSString *str2) &#123; return [str1 intValue] + [str2 intValue];&#125;;NSLog(@"Result = %d", blockExp(@"1", @"2"));// 打印结果：Result = 3 无参无返的 Block无参数无返回值的 Block 。1234void (^block1)() = ^() &#123; &#125;;block1() 有参无返的 Block无参数无返回值的 Block 。1234void (^block2)(NSString *) = ^(NSString *str) &#123; &#125;;block2(@"Obj"); 有参有返的 Block无参数有返回值的 Block 。12345int (^block3)(int num) = ^(int num) &#123; return num+1;&#125;;NSLog(@"Result = %d", block3(10));// 输出结果：Result = 11 Block 的实际应用Block 结合 typedef 使用在实际使用 Block 的过程中，我们可能需要重复地声明多个相同返回值相同参数列表的 Block 变量，如果总是重复地编写一长串代码来声明变量会非常繁琐，所以我们可以使用 typedef 来定义 Block 类型。123456789// 定义一种无返回值有参数的 Block 类型typedef void (^SayHello)(NSString *str);// 可以像 OC 中声明变量一样使用 Block 类型 SayHello 来声明变量并调用SayHello hello = ^(NSString *saySrr)&#123; NSLog(@"%@", saySrr);&#125;;hello(@"Hello World"); // 打印结果：Hello World Block 作为属性1234// 定义一种有参有返的 Block typedef NSString *(^MyBlock)(int a);// 定义一个 MyBlock 属性@property (nonatomic,copy)MyBlock block; Block 作为函数参数12// 定义一个 Block typedef void (^MyBlock)(UIColor* aColor); 这样我们就可以使用 MyBlock 来表示这个 Block，将 MyBlock 加入到函数参数中来声明一个函数。1234- (void)setMyBlock:(MyBlock)block &#123; block([UIColor redColor]);&#125; 可在任意地方调用这个函数。12345[secondVc setMyBlock:^NSString *(UIColor* aColor) &#123; NSLog(@"%@", aColor); wself.view.backgroundColor = aColor; return @"";&#125;]; 我们平时锁使用的许多回调当中大多都是这样的形式，其较多的就是网络请求回调了，我们只需要调用方法，然后在回调当中就可以对结果进行操作，很多苹果自己写的 API 都是使用了这样的方法。这样做的好处就是形式上十份简洁，当然像这种地方你使用 delegate 肯定也是可以的，但是表现上就没有 Block 那么简洁，使用起来也没有 Block 那么方便。 使用 Block 在页面中反向传值Blcok 是一个匿名函数，同时也是一个指针，那么使用 Block 就可以弥补在 iOS 中函数传递的功能。在页面 B 中定义一个 Block 并声明一个 Block 变量。12345678// 声明部分typedef void(^BlockChange)(NSString *titleStr, UIColor *bgColor);@property(nonatomic, copy)BlockChange blockChange;- (void)setChangeColorBlock:(BlockChange) block;// 实现部分- (void)setChangeColorBlock:(BlockChange) block &#123; self.blockChange = block;&#125; 在页面 A 中的代码。123456SecondViewController *secondVc = [[SecondViewController alloc] init];__weak FirstViewController * wself = self;[secondVc setChangeColorBlock:^(NSString *titleStr, UIColor *bgColor) &#123; wself.view.backgroundColor = bgColor; wself.tabBarItem.title = titleStr;&#125;]; 在页面 B 的任意适当位置调用 block 变量。1self.blockChange(@"传递颜色", [UIColor grayColor]); 这样 @”传递颜色” 和 [UIColor grayColor] 就从界面 B 传到了界面 A 。 注意事项使用 __block 修改局部变量Block 可以访问局部变量，但是不能修改。如果想要修改局部变量，需要使用 __block 来修饰变量。12345__block int multiplier = 7;int (^myBlock)(int) = ^(int num) &#123; multiplier ++;//这样就可以了 return num * multiplier;&#125;; 但是如果局部变量是数组字典或者指针的时候，只 copy 了这个指针，两个指针指向同一个地址，block 只修改指针上的内容。12345NSMutableArray *arrayInsert = [NSMutableArray array];void(^blockLog)() = ^&#123; [arrayInsert addObject:@"Obj"]; NSLog(@"array = %@", arrayInsert);&#125;; 例子中的 arrayInsert 是一个指针，指向一个可数组。在 block 里面，并没有修改这个指针，而是修改了这个指针指向的数组。换句话说，指针保存的是一块内存区域的地址，在block 里，并没有改变这个地址，而是读取出这个地址，然后去操作这块地址空间的内容，这是允许的。 因为声明 block 的时候实际上是把当时的临时变量又复制了一份，在 block 里即使修改了这些复制的变量，也不影响外面的原始变量。即所谓的闭包。但是当变量是一个指针的时候，block里只是复制了一份这个指针，两个指针指向同一个地址。所以，在block里面对指针指向内容做的修改，在block外面也一样生效。 使用 __week 修改局部变量如果在 Block 中使用附有 __strong 修饰符的对象类型自动变量，那么当 Block 从栈复制到堆时，改对象为 Block 所有。这样容易引起循环引用，从而发生内存泄漏。然而我们只需要保证当前控制器也就是 self 在需要释放的时候正确释放就可以。1__weak FirstViewController * wself = self; 我们定义一个 wself 变量并使用 __weak 修饰符，在 Block 代码块中，所有需要 self 的地方都用 wself 来替代。这样就不会增加引用计数，所以 Block 持有 self 对象就不会造成循环引用，从而造成内存泄漏。 注意：在使用 block 前需要对 block 指针做判空处理，如果是MRC的编译环境下，要先 release 掉 block 对象。将 block 赋值为空，是解掉循环引用的重要方法。]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>block</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 简单而实用的动态加载闪屏图方法]]></title>
    <url>%2F2015%2F07%2F17%2F2015%2FiOS-loading-flash-screen-dynamically-metohd%2F</url>
    <content type="text"><![CDATA[iOS 开发中往往有动态更换闪屏图或者在闪屏图后加载广告的需求，如果是在闪屏后加载广告，在闪屏展示对应的广告页面即可。但是如果要动态更新闪屏图启是不可以的，如果要想实现这种效果，只能做出一种假象来，让人感觉你的启动图就是动态获取的。 实现的思路是先把启动图空白或者部分空白，然后用一个 VC 或者 UIimageview 来做动态获取服务器图片然后显示的功能，这个 VC 的界面一定要做的和你的启动页一模一样。然后在第一个 VC 中，设置代码加动画，设置请求下来的启动图什么的就都可以了。 代码如下：1234567891011121314151617181920212223- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; MainViewController *mainVc = [[MainViewController alloc] init]; UINavigationController *navi = [[UINavigationController alloc] initWithRootViewController:mainVc]; self.window.rootViewController = navi; [self.window makeKeyAndVisible]; // 在 window 上放一个 imageView UIImageView *imageView = [[UIImageView alloc]initWithFrame:[UIScreen mainScreen].bounds]; imageView.image = [UIImage imageNamed:@"img_bg-1"]; [self.window addSubview:imageView]; // 执行动画 [UIView animateWithDuration:2 animations:^&#123; // 两秒内图片变大为原来的 1.3 倍 imageView.transform = CGAffineTransformMakeScale(1.2,1.2); imageView.alpha = 0; &#125; completion:^(BOOL finished) &#123; // 动画结束，移除 imageView，呈现主界面 [imageView removeFromSuperview]; &#125;]; return YES;&#125;]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>动态闪屏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 第三方库 FMDB 详解]]></title>
    <url>%2F2015%2F06%2F23%2F2015%2FiOS-thirdlib-FMDB-detailed-annotation%2F</url>
    <content type="text"><![CDATA[iOS 中原生的 SQLite API 在进行数据存储的时候，需要使用 C 语言中的函数，操作比较麻烦。于是，就出现了一系列将 SQLite API 进行封装的库，例如 FMDB、PlausibleDatabase 和 qlitepersistentobjects 等。 FMDB 简介什么是 FMDBFMDB 是一款简洁、易用的封装库。因此，在这里推荐使用第三方框架 FMDB，它是对 libsqlite3 框架的封装，用起来的步骤与 SQLite 使用类似，并且它对于多线程的并发操作进行了处理，所以也是线程安全的。 FMDB 的优缺点优点： 对多线程的并发操作进行处理，所以是线程安全的（重要特性之一）。 以 OC 的方式封装了 SQLite 的 C 语言 API，使用起来简洁、高效，没有原来的一大堆晦涩难懂、影响开发效率的 C 语句，更加面向对象。 FMDB 是轻量级的框架，灵活易用。 缺点： 因为它是 OC 的封装的，只能在 iOS 开发的时候使用，所以在实现跨平台操作的时候存在局限性。 FMDB 框架中的重要类 FMDatabase：一个 FMDatabase 对象就代表一个单独的 SQLite 数据库（注意并不是表），用来执行 SQL 语句。 FMResultSet：使用 FMDatabase 执行查询后的结果集。 FMDatabaseQueue：用于在多线程中执行多个查询或更新，线程安全的。 FMDB 的详细使用步骤准备步骤 在工程中导入 FMDB，可以选择手动下载导入 GitHub-FMDB 或使用 CocoaPods 导入。 导入 libsqlite3.0 框架或导入 libsqlite3 框架（而这本质一致，libsqlite3.0 指向 libsqlite3）。 在需要用到 FMDB 的控制器（或模型）地方导入头文件 import FMDatabase.h 。本地的 .sqlite 的查看，非常推荐火狐浏览器中的插件 SQLite Manager 。 创建一个继承于 NSObject 的 Student 类，用来进行数据的增删改查。 1234567#import &lt;Foundation/Foundation.h&gt;@interface Student : NSObject@property (nonatomic, assign) int num; // 学号@property (nonatomic, copy) NSString *name; // 名字@property (nonatomic, copy) NSString *sex; // 性别@property (nonatomic, assign) int age; // 年龄@end 数据库的创建12345678910111213141516171819@interface MainViewController () &#123; FMDatabase *_db; // FMDB 对象 NSString *_docPath; // 沙盒（数据库）路径&#125;@end// 1. 获取文件路径_docPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject]; NSLog(@"文件路径：%@", _docPath); // 2. 数据文件名称NSString *fileName = [_docPath stringByAppendingPathComponent:@"student.sqlite"]; // 3. 获取数据库_db = [FMDatabase databaseWithPath:fileName];if ([_db open]) &#123; NSLog(@"打开数据库成功");&#125; else &#123; NSLog(@"打开数据库失败");&#125; 然后可以打开 _docPath 的路径，可以看到名为 student.sqlite 的数据库已经创建好了。 数据表的创建1234567// 创建表格BOOL result = [_db executeUpdate:@"CREATE TABLE IF NOT EXISTS table_student (id integer PRIMARY KEY AUTOINCREMENT, name text NOT NULL, age integer NOT NULL, sex text NOT NULL);"];if (result) &#123; NSLog(@"创建数据表成功");&#125; else &#123; NSLog(@"创建数据表失败");&#125; 使用火狐浏览器的 SQLite Manager 插件打开 student.sqlite 可以看到table_student 表已经被创建好了。 增加数据12345678910// 插入数据NSString *name = [NSString stringWithFormat:@"王胖子"];int age = 36;NSString *sex = @"男";BOOL resurtInsert = [_db executeUpdate:@"INSERT INTO table_student (name, age, sex) VALUES (?,?,?)",name,@(age),sex];if (resurtInsert) &#123; NSLog(@"插入成功");&#125; else &#123; NSLog(@"插入失败");&#125; 删除数据1234567// 1.不确定的参数用？来占位 （后面参数必须是oc对象,需要将int包装成OC对象）// int idNum = 1;// BOOL result = [_db executeUpdate:@"DELETE FROM t_student WHERE id = ?",@(idNum)];BOOL result = [_db executeUpdate:@"DELETE FROM table_student WHERE name = ?",@"王胖子"];if (result) &#123; NSLog(@"删除成功");&#125; 修改数据123456NSString *oldName = @"王胖子";NSString *newNAme = @"无邪";BOOL result = [_db executeUpdate:@"UPDATE table_student set name = ? WHERE name = ?", newNAme, oldName];if (result) &#123; NSLog(@"修改成功");&#125; 查询数据123456789// FMResultSet *resultSet = [_db executeQuery:@"SELECT * FROM table_student"];FMResultSet *resultSet = [_db executeQuery:@"SELECT * FROM table_student WHERE id &lt; ?", @(4)];while ([resultSet next]) &#123; int idNum = [resultSet intForColumn:@"id"]; NSString *name = [resultSet objectForColumn:@"name"]; int age = [resultSet intForColumn:@"age"]; NSString *sex = [resultSet objectForColumn:@"sex"]; NSLog(@"学号：%@ 姓名：%@ 年龄：%@ 性别：%@",@(idNum),name,@(age),sex);&#125; 表的删除1234BOOL result = [_db executeUpdate:@"DROP TABLE IF EXISTS table_student"];if (result) &#123; NSLog(@"删除成功");&#125; 执行之后，刷新 SQLite，可以看到 table_student 表已经被删除了。]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>FMDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 如何选择和获取设备的唯一标识符]]></title>
    <url>%2F2015%2F04%2F14%2F2015%2FiOS-select-acquire-device-unique-identifying%2F</url>
    <content type="text"><![CDATA[iOS 开发中常常需要将一些用户的使用日志等上传的服务器，方便反馈查询错误。要识别用户，就要选择一个标识符，通过这个标识符来识别这个用户的设备，这个标识符要能够保证一个设备上返回的值是一样的，并且在其他设备上不会出现相同的值，那么该如何获取这个到 iOS 设备的标识符。 概述在 iOS 7 之前，曾经有过很多方法来识别用户的设备，从最原始的设备 UDID、mac 地址，到被各广告统计平台广泛使用的开源方案 OpenUDID 。 但 iOS 7 之后，Apple 更加注重保护用户隐私，随着 AppStore 开始拒绝接受使用 UDID 的应用，到 mac 地址在在所有设备上都返回相同的值，再到 iOS7 上对剪贴板的限制，导致 OpenUDID 无法被不同应用共享相同的值，注定了上面提到的这些 id 们不得不退出历史的舞台。 那么我们该用什么来追踪和识别用户？ idfa: 适用于对外：例如广告推广，换量等跨应用的用户追踪等。 idfv: 适用于对内：例如分析用户在应用内的行为等。 被弃用的方法UDID设备唯一标识符（Unique Device Identifier）之前被各种国内外统计平台，应用开发商广泛使用，后 Apple 从 2013 年 05 月 01 日起拒绝接受使用 UDID 的应用。 Mac 地址每一个网卡都有一个唯一的标识，即 Mac 地址，用来标识一个手机是绰绰有余，也有一些开源的方案也用到了它，国内 UMTrack 等也用它作为过主 id，随着 iOS 7 返回同样的值后，不得不被弃用。 OpenUDID在 Apple 拒绝 UDID 后，OpenUDID 作为独立于 Apple 的开源方案，被广大的开发者所接受，各大统计广告平台都从 UDID 等方案切换到 OpenUDID 的方案，但同样由于 iOS 7 对剪贴板的限制，导致同一个设备上应用间，无法再共享一个 OpenUDID，即 OpenUDID 作为设备唯一标识的能力被大大削弱。 DeviceTokenDeviceToken 是推送用的唯一标识，但是用户如果没开推送，或者拒绝了推送，这个便没有了。 推荐的方法idfa 全名：advertisingIdentifier 示例代码： 12#import &lt;AdSupport/AdSupport.h&gt;NSString *adIdStr = [[[ASIdentifierManager sharedManager] advertisingIdentifier] UUIDString]; 适用于：iOS 6.0 之后，适用于对外，例如广告推广，换量等跨应用的用户追踪等。 说明：直译就是广告id， 在同一个设备上的所有 App 都会取到相同的值，是苹果专门给各广告提供商用来追踪用户而设的，用户可以在 设置|隐私|广告追踪 里重置此 id 的值，或限制此 id 的使用，故此 id有 可能会取不到值，但好在 Apple 默认是允许追踪的，而且一般用户都不知道有这么个设置，所以基本上用来监测推广效果，是戳戳有余了。 注意：由于 idfa 会出现取不到的情况，故绝不可以作为业务分析的主 id，来识别用户。 idfv 全名：identifierForVendor 示例代码： 1NSString *idfv = [[[UIDevice currentDevice] identifierForVendor] UUIDString]; 适用于：iOS 6.0 之后，适用于对内，例如分析用户在应用内的行为等。 说明：顾名思义，是给 Vendor 标识用户用的，每个设备在所属同一个 Vender 的应用里，都有相同的值。其中的 Vender 是指应用提供商，但准确点说，是通过 BundleID 的 DNS 转的前两部分进行匹配，如果相同就是同一个 Vender，例如对于 com.somecompany.appone 和 com.somecompany.apptwo 这两个 BundleID 来说，就属于同一个 Vender，共享同一个 idfv 的值。和 idfa 不同的是，idfv 的值是一定能取到的，所以非常适合于作为内部用户行为分析的主 id，来标识用户，替代 OpenUDID。 注意：如果用户将属于此 Vender 的所有 App 卸载，则 idfv 的值会被重置，即再重装此 Vender 的 App，idfv 的值和之前不同。 总之，Apple 越来越注重用户的隐私，也越来越去掌控一些关于隐私的设置，所以跟随 Apple 的政策，使用 idfv 和 idfa 作为设备的唯一标识符为最佳。]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>设备标识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS NSTimer 注意事项及 GCD 定时器的使用]]></title>
    <url>%2F2015%2F02%2F19%2F2015%2FiOS-NSTimer-notice-and-GCDTimer-usage%2F</url>
    <content type="text"><![CDATA[NSTimer 定时器 NSTimer 的创建和使用123456// 创建和开始NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(beginCount) userInfo:nil repeats:YES]; 注意：Timer 自动启动。repeats 参数表示是否循环使用定时器，NO 表示只调用一次。将计数器的 repeats 设置为 YES 的时候，self 的引用计数会加 1 。因此可能会导致 self 不能 release，所以，必须在 viewWillAppear 的时候，将计数器 timer 关闭，否则可能会导致内存泄露。 NSTimer的关闭123// 关闭[timer invalidate];timer = nil; 注意：一定要赋值为空，这样才是真的释放。 NSTimer的暂停和继续1234// 暂停[timer setFireDate:[NSDate distantFuture]];// 继续[timer setFireDate:[NSDate date]]; NSTimer的弊端和注意下事项 必须保证有一个活跃的 runloop，子线程的 runloop 是默认关闭的，这时如果不激活 runloop，performSelector 和 scheduledTimerWithTimeInterval 的调用将是无效的。 NSTimer 的创建与撤销必须在同一个线程操作、performSelector 的创建与撤销必须在同一个线程操作。 内存管理有潜在泄露的风险。 如果不是通过 invalidate 来关闭是无法停止的，还有持有 self，造成对象无法释放。 所以推荐用 dispatch 的 timer。 GCD 定时器 GCD 定时器的创建和执行1234567891011121314151617- (void)startGCDTimer&#123; // GCD定时器 static dispatch_source_t _timer; NSTimeInterval period = 1.0; //设置时间间隔 dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue); dispatch_source_set_timer(_timer, dispatch_walltime(NULL, 0), period * NSEC_PER_SEC, 0); //每秒执行 // 事件回调 dispatch_source_set_event_handler(_timer, ^&#123; // 在主线程中执行 dispatch_async(dispatch_get_main_queue(), ^&#123; NSLog(@"Do Count"); &#125;); &#125;); dispatch_resume(_timer);&#125; 注意：dispatch_source_t 必须是全局或 static 变量。 GCD 定时器的停止1234567-(void) stopGCDTimer&#123; // 停止 if(_timer)&#123; dispatch_source_cancel(_timer); _timer = nil; &#125;&#125; GCD 定时器的暂停和继续123456789101112-(void) pauseGCDTimer&#123; // 暂停 if(_timer)&#123; dispatch_suspend(_timer); &#125;&#125;-(void) resumeGCDTimer&#123; // 继续 if(_timer)&#123; dispatch_resume(_timer); &#125;&#125;]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>NSTimer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 开发笔记之 UISlider]]></title>
    <url>%2F2014%2F11%2F09%2F2014%2FiOS-objc-development-note-UISlider%2F</url>
    <content type="text"><![CDATA[改变 UISlider 滑道的高度12345// 控制 slider 的宽和高，这个方法才是真正的改变 slider 滑道的高- (CGRect)trackRectForBounds:(CGRect)bounds&#123; return CGRectMake(0, 0, CGRectGetWidth(self.frame), _adjustHeight);&#125; 注意：此方法直接调用是无效的，要重写一个继承于 UISlider 的子类，在子类中重写下面的方法才有效。1-(CGRect)trackRectForBounds:(CGRect)bounds; 改变 UISlider 滑块的大小可以使用 setThumbImage 方法，滑块的大小会随设置的图片尺寸改变。123[_progressSlider setThumbImage:[UIImage imageNamed:@"ic_slider"] scaleToSize:CGSizeMake(10, 10) forState:UIControlStateNormal]; 改变 UIImage 尺寸的方法，可加在 UIImage 的 Category 方法中。1234567891011121314/* 对原来的图片的大小进行处理 @param image 要处理的图片 @param size 处理过图片的大小 */+ (UIImage *)imageNamed:(NSString *)imagestr scaleToSize:(CGSize)size&#123; UIImage *image = [UIImage imageNamed:imagestr]; UIGraphicsBeginImageContext(size); [image drawInRect:CGRectMake(0,0, size.width, size.height)]; UIImage *scaleImage=UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return scaleImage;&#125; 增加触控范围在 UISlider 的拖动手势不灵敏的时候此方法有效。同样需要子类继承 UISlider，然后重写下面的方法。1234567- (CGRect)thumbRectForBounds:(CGRect)bounds trackRect:(CGRect)rect value:(float)value&#123; // y 轴方向改变手势范围 rect.origin.y = rect.origin.y - 10; rect.size.height = rect.size.height + 20; return CGRectInset([super thumbRectForBounds:bounds trackRect:rect value:value], 10, 10);&#125; 监听 Slider 滑动停止当监听 Slider 值变化的时候，如果直接在 slider 上绑定事件，则改变一次就需要需要处理一次。这种在某些情况下是不合理的。解决方法如下。1234// 先将 slider 绑定一个事件[_progressSlider addTarget:self action:@selector(sliderValueChanged:) forControlEvents:UIControlEventValueChanged];// 将其属性设置成 NO_progressSlider.continuous = NO; 这样就只会在停止滑动的时候发送一个 valuechange 的通知，在 sliderValueChanged 方法中实现你需要进行的操作即可。 持续更新中……]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>UISlider</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 开发 OC 拓展类的几种方式]]></title>
    <url>%2F2014%2F10%2F03%2F2014%2FiOS-objc-class-extension-methods%2F</url>
    <content type="text"><![CDATA[继承继承：子类 subClass作用：可以通过类的继承来增添父类的属性和方法。写法：在 .h 文件中1@interface Student : Person 类目类目：Category，也叫分类、类别。作用：可以增添父类的方法，但是不能定义变量。多用于不知道源码的情况下，对父类进行拓展。例如用来拓展系统类。写法：在 .h 和 .m 中，文件名为 “父类名+分类名” 格式。在 @interface 和 @implementation 后 “父类名(分类名)” 。123// NSString+autoResize@interface NSString (autoResize)@implementation NSString (autoResize) 延展延展：Extension作用：定义私有方法，可以隐藏不对外公布的方法，多用于隐藏一些中间步骤的方法。写法：在 .m 文件中的 @implementation 前实现。12345@interface Person() &#123; NSString * _age;&#125; - (void)logAge;@end 协议协议方法：protocol作用：可以实现类似多继承的方法，一个类遵守多个协议。写法：协议只有 .h 文件，定义了方法。123456@required //默认是必须实现的 - (void)method1; - (void)method2; @optional //可以选择实现 - (void)method3;]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
  </entry>
</search>
