<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOS 大量图片处理导致占内存过高的优化方法]]></title>
    <url>%2F2018%2F02%2F12%2F2018%2FiOS-large-number-UIimage-memory-problem-optimization%2F</url>
    <content type="text"><![CDATA[最近项目中有一个视频剪辑的功能，其中需要把视频的帧图取出来，项目中使用了大量的 collectionView + imageView。这就涉及了大量的图片处理，会导致程序的内存占用飙升，如果此时刚好可用内存不大，就会导致程序闪退。 通常报错 [GatekeeperXPC] Connection to assetsd was interrupted or assetsd died ，就是内存管理出了问题了，例如使用 UIImagePickerController 这个方法来调用图片库和相机的时候，选择的图片是原图，会被加载到内存并占用非常大的内存空间，连续选择多张图片会直接使得程序闪退。这里简单的总结下处理该问题的几种优化方法。 检查 UIImage 的加载方式尽量不要使用 [UIImage imageNamed:nil]; 这种方式加载，如果缓存中已存在该图片，会从直接从缓存中取得资源，使资源一直停留在内存当中，不会随着对象的销毁而销毁。且相同的图片，图片不会重复加载，内存占用较大。 如果内存中不存在该图片，会通过传入的文件名对整个工程进行遍历，如果如果找到对应的图片， iOS 系统首先要做的是将这个图片放到系统缓存中去，以备下次使用的时候直接从系统缓存中取，那么试想一下，如果要加载的这个图片的文件量很多，文件大小很大，内存不足，内存泄露，甚至是程序的崩溃都是很容易发生的事。 使用 imageWithContentsOfFile 方法代替。12NSString *imageFile = [NSString stringWithFormat:@"%@/%@.jpg", [[NSBundle mainBundle] resourcePath], fileName];UIImage* image = [UIImage imageWithContentsOfFile:imageFile]; imageWithContentsOfFile 仅仅是加载图片，图像数据不会被缓存。因此在加载较大较多图片，以及图片使用情况很少的时候可以使用这两个方法，降低内存消耗，提高程序的稳定性。 综上，当图片文件较小，使用比较频繁的时候那么使用 imageNamed 比较好，例如 UITableViewCell、UICollectionCell 等加载同一个图标的时候，这对图像的重复利用是非常有优势的。使用方式加载，图像会被系统以数据的形式加载到程序，当不需要大量重用该图像，或者你需要将图像以数据方式存储到数据库等时，请尽量使用 imageWithData 的方式加载图像。 对图片进行压缩使用 UIImageJPEGRepresentation1NSData *compressData = UIImageJPEGRepresentation(compressImage, 0.5); // 注意 : 0.5 为压缩系数，和压缩后大小无关 UIImageJPEGRepresentation 函数需要两个参数：图片的引用和压缩系数。如果对图片的清晰度要求不高，可以通过设置函数的第二个参数，来降低图片数据量。但是压缩效果一般，17MB 的视频通过 0.5 压缩系数的压缩后大小大约 1.8MB 左右（和原图片质量色彩等有关），所以不推荐使用该方法。 使用 UIGraphicsBeginImageContext选择图片的时候，可根据当前设备的屏幕大小来进行截图，这样得来的图片会由原像素降低为手机屏幕的像素，这样得来的图片大小之后 10-25K 的大小（当然可在其基础上再使用 UIImageJPEGRepresentation 进行压缩），画质在不进行缩放的情况下和原图是一样的。推荐使用该方法，压缩效果比较理想，方法如下。 123456789101112131415161718192021222324252627- (UIImage *)compressImageWith:(UIImage *)image&#123; float imageWidth = image.size.width / screnWidth; float imageHeight = image.size.height / screnHeight; float width = fmax(imageWidth, imageHeight); float height = image.size.height/(image.size.width/width); float widthScale = imageWidth /width; float heightScale = imageHeight /height; // 创建一个bitmap的context, 并把它设置成为当前正在使用的context UIGraphicsBeginImageContext(CGSizeMake(width, height)); if (widthScale &gt; heightScale) &#123; [image drawInRect:CGRectMake(0, 0, imageWidth /heightScale , height)]; &#125; else &#123; [image drawInRect:CGRectMake(0, 0, width , imageHeight /widthScale)]; &#125; // 从当前context中创建一个改变大小后的图片 UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext(); // 使当前的context出堆栈 UIGraphicsEndImageContext(); return newImage;&#125; 总结：开发中使用到耗费内存的图片加载时，在保证可接受的清晰度范围内。对图片进行适当的压缩处理，优化显示效果，释放内存压力还是有必要的。当然这不只是方法因为是一种思路。我在项目中遇到的问题是从视频中取取大量对应的帧图片，所以实际的解决方法是先对视频的质量进行了压缩处理，也有效的降低了图像处理的压力。 附录：获取 UIimage 大小的方法。12NSData * imageData = UIImageJPEGRepresentation(image,1);NSUInteger newLength = [imageData length]/1024;]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>内存优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017 年终总结]]></title>
    <url>%2F2018%2F01%2F23%2F2018%2Fsummary-year-end-2017%2F</url>
    <content type="text"><![CDATA[在一个崇高的目标支持下，不停地工作，即使慢，也一定会获得成功。 – 爱因斯坦 自去年开始写年终总结，虽然有些目标由于各种原因没有实现，但对于个人的总结提升还是有一定的帮助的。适当的进行总结并制定计划总是好的，所以决定要保持下去这个习惯。总结下去年一年的工作生活，制定新一年制定目标并按月核对，以资鼓励！ 2017 年较去年来讲算是变动比较大的一年，无论是工作的变故，还是个人生活方面的一些事情。2017 年终总结和2018 新年目标总结如下。 2017 总结生活17 年十一月份之前，工作还算比较稳定，平时上班敲码加班…，闲暇之余约上几个好友聚餐出游，生活还算惬意。11 月份底离开了呆了差不多三年的深圳，回到了阔别已久的北京，找了一份新的工作。离开时还是有些不舍得，毕竟生活了挺久，还有一群 nice 的小伙伴~。 作为一个地地道道的北方人，表示生活在南方还是挺舒服的，除了有时候有点潮…。整体的大环境很不错，毕竟也是超一线城市，发展自然不用多说。天气好，冬天只有一个月，剩下的都是夏天，虽说时不时就刮刮台风下下暴雨，但整体都是很舒服的。最最让人喜欢的一点就是吃的多，肠粉、砂锅粥、潮汕牛肉… 哎不说了，越说越是想念。如果不是个人的一些原因，真想再呆上几年。回到北京找工作、找房、装修，新工作新环境开始… 。 工作不知不觉做 iOS 开发已经三年了，想来也不能全算开发，因为开始的时候大部分时间只能算是码农，然后慢慢的学习摸索，虽说现在的能力水平也不算很高，但毕竟也在不断的进步着努力着。每个人都有这样一个循序渐进的过程，只不过努力的方向不同，所以成长也大不相同。 去年一年的工作中，更多的工作精力都是投入在一些组件化和库开发中。其中更多要求的是个人的架构能力和设计能力，当然在这个各种中也得到了相应的实践和提升。过程中意识到了自己很多的不足，其中差的比较多的是算法能力，自己虽是计算机专业出身，但由于工作中长时间不使用，并且平时这方面也疏于学习，单只现在比较差。另一方面，对部分概念和设计的理解研究还不够深入，导致某些代码的效率和稳定性还不能达到最佳。在接下来的计划中会以提高这些不足并拓宽层面为主要目标。 目标实现全年的目标实现整体来讲并不理想，具体的放在目标里面讲。虽然部分原因是由于加班较多空余时间较少，但大部分原因还是处在自身的，不过这也并不全是坏的，发现问题然后解决问题，就会进步。 总结了下其中的原因。一点是因为碎片化时间的利用率不够，虽说经常加班，但是时间还是有的，都是些零零散散的时间，很少有大段集中的时间。在这样碎片化的时间总是容易被忽视，觉得干不了多少事情，不如打会游戏看个视频，从而导致了很多的时间被浪费掉，如果能最大限度的把这些时间利用起来，对达到目标无疑是非常重要的。另一方面，就是计划的系统性，去年的计划定的虽然比较详细，但是执行的过程中却没有系统性的进行，从而导致为了计划而计划，并没有达到预期的效果，除了锻炼学习以外，我希望更多的是能够培养自己对于技术的习惯性和兴趣热情。 锻炼身体是革命的本钱，从来刚开始干开发的时候就意识到了这个问题的严肃性。虽然去年一年并没有制定相关的计划，也没有像身边的几个小伙伴一样办健身卡、买增肌粉、吃健身套餐…，单多少还有运动些的。主要是跑步，频率大概每周 4-5 次，每次平均 6 公里左右，一开始很难，主要还是坚持。在深圳室外跑步还是很舒服的，空气很新鲜，六月份之前主要在宝安体育馆，体育场 10 圈，每圈 600 米。六月份搬家到南海大道后，开始去深圳湾夜跑，跑步的人很多，也有很多过来骑行的人，跑完后坐在海边眺望香港吹吹海风，舒服的很。自从回到北京前后的这段时间，由于事情比较多，再加上天气比较冷，所以好不容易坚持下来的跑步就断掉了。最近总感觉腰酸背痛腿抽筋，看来是时候重新抓起来了。 2018 年目标博客更新总结 旧目标: 经常在个人博客中总结遇到的问题或技术点，每月至少一篇总结性文章，Blog 新增 10 篇高质量博客。这个目标实现的算是比较好的了，虽然写的不是什么高大上的东西，或许某些人看来也没什么深度和技术含量，但都是自己平时遇到的一些问题和一些技术的相关总结，对个人的提升还是比较大的。另外如果是有遇到类似问题的人，我想还是会有些帮助的，这个也是一定要坚持下去的。 新目标: 保持个人博客中总结遇到的问题或技术点的更新频率，每月至少一篇。 读书 旧目标: 读三本书：非技术的《左手天才，右手疯子》，技术类的 《 React：用 JavaScript 开发移动应用》和《 ReactNative：引领未来的用户界面开发框架》。读书的目标实现比较差，其中《天才》因为是很久之前就想看的一本书，所以读完了。两本 RN 的书只读了 50% 左右。本打算先定一个小目标，把这两本学完。但那天收拾的时候突然发现两本尘封已久的书，著名的《Effective Objective-C 2.0》和《Objective-C高级编程：iOS与OS X多线程和内存管理》，刚开始开发的时候有读过，但没有读完，对其中的一些内容理解的也不够深刻，我想现在再去读应该也会有不同的看法，所有决定再从头读一遍，至于未完成的计划需要在平时挤出更多的时间来完成。 新目标: 重新读完 《Effective Objective-C 2.0》和《Objective-C高级编程：iOS与OS X多线程和内存管理》，完成 RN 的两本书。 前段技术 旧目标: 学习前端技术（HTML+CSS），目标是建一个站。这一块的目标完成度一般，HTML+CSS 目前仍处在一个入门的阶段，需要进一步的提升与进阶。当初的想法是光学习 OC 一门语言是不够的，想着多学几门语言，往全栈工程师方向发展，后来发现自己的 OC 研究不算很透彻，全栈似乎也并不适合我。之所以会学习前段，更多的是因为兴趣，也是为了拓宽自己的视野和技术广度。 新目标: 进阶 HTML+CSS+JavaScript 的学习，有机会的话希望能用在项目实战中。 Swift 旧目标: 推进 Swift 的学习，用 Swift 写出自己的一个开源的播放器项目。完成度最差的就应该是这个了，试着写过一些东西。可能是 OC 用的太多了，所以好多语法都好难改…，即使是更加简便了。目前 Swift 的版本也算是比较稳定了，发展速度也比较快，也是时候开搞一波了！ 新目标: 实际开发中使用 Swift，进阶高度和深度。 开源社区 旧目标:GitHub 开源 2 个项目，每个项目收获 50 个 Star。/ StackOverflow 新增 50 reputation： 1 -&gt; 51。/SegmentFault 新增 50 声望： 81 -&gt; 131。过去的一年中开源社区的活跃度都不算太高，虽然说用的挺多的 Github 中的优秀项目 StackOverflow 和 SegmentFault 中的问答，能解决很多开发中遇到的问题，但个人却很少参与其中，参与一些开源库的贡献、一些问题的提问回答等。其实这些都是蛮重要的，无论是在开发中或是生活中，交流沟通总是解决问题提升自己的有效途径。这一点需要加强。 新目标: 提高开源社区的参与度，今年不再做具体的量化目标，尽量活跃就好。 生活就写一点，锻炼身体，主要是跑步🏃，贵在坚持。 新目标: 每周 4-6 次， 单次 30 分钟以上，单次 5 公里以上。 总结：2018年，调整整体目标，深入 Objective-C，左手前段，右手 Swift, 向 T 型发展，加油！！！]]></content>
      <categories>
        <category>日常总结</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo 如何备份好你的博客]]></title>
    <url>%2F2018%2F01%2F21%2F2018%2FHexo-how-to-backups-bolg-method%2F</url>
    <content type="text"><![CDATA[无论什么时候数据备份都是相当必要的，不要等出现意外情况的时候数据丢失就追悔莫及了，比如我自己…。早期建站的时候就考虑过数据源码备份的事情了，但是后来把博客转移后，也就没再做了。 那么要怎么把博客源码高效方便的备份好呢？如果你想用 U 盘或者网盘，把文件从一台电脑拷贝到另一台电脑也是可的，只不过麻烦的很。解决方案的基本思路是，在你部署博客的 Github 仓库 username.github.io 新建一个 hexo 分支，用来提交和保存博客源码，默认的 master 分支用来部署静态网页，两个分支，各司其职。 可以参考我的仓库 Lewanny.github.io，两个分支一个 master，另一个 hexo。 备份方法 克隆 Github 上用来部署静态网页的 username.github.io 项目文件到本地。 1git clone https://github.com/yourname/xxx.github.io.git 删除文件夹里除了 .git 的其他所有文件。 把 hexo 项目文件下的所有文件全部复制过来，或者复制 _config.yml，themes/，source/，scaffolds/，package.json，.gitignore 这些文件即可。 检查下里面是否有 .gitignore 文件，如果没有就输入 touch .gitignore，创建一个即可。 新建名为 hexo 的分支并切换到这个分支上。（分支名字随意的） 提交复制过来的文件到暂存区，探后提交并推送分支到 Github 即可。 123git add . git commit -m &quot;新建备份分支&quot;git push origin hexo 这样一来，username.github.io 仓库就有 master 分支和 hexo 两个分支了，分别保存静态网页和源文件。 备份完成后，Hexo 更新的操作不便（不必切回到 master 分支） Hexo d -g，但不要忘记每次更新博客后执行 git add . 、 git commit -m &quot;&quot;、 git push origin hexo 重新提交源文件到备份分支上。 恢复方法重装电脑后，或者换了其他电脑后，想要在其他电脑上操作博客，只要把备份的源文件克隆下来，重新安装 Hexo 环境，然后执行 npm install 安装依赖之后就可以了。 安装 git 。 安装 Node.js 和 npm 。 将备份的源文件内容拷贝至本地。 1git clone -b hexo https://github.com/yourname/xxx.github.io.git 在文件夹内执行命令 npm install hexo --save 安装依赖即可。 操作完成后，整个博客就恢复完成了。更新或修改博客后依旧是执行 hexo d -g 更新。执行 git add . 、 git commit -m &quot;&quot;、 git push origin hexo 提交源文件备份。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo 博客文章提交 Baidu 和 Google 收录]]></title>
    <url>%2F2018%2F01%2F14%2F2018%2FHexo-submit-article-baidu-google-to-included%2F</url>
    <content type="text"><![CDATA[我们把 Hexo 托管在 Github 上，但是 Github 毕竟是国外的，访问速度上还是有点慢，并且百度的爬虫无法趴到 Github 上的数据，提交百度收录也自然是不存在的。所以同时部署了一套在国内的托管平台，也就是 Coding (也就是之前的 Gitcafe，部署方法和 Github 雷同据不写了)。这样国内访问的时候解析到 Coding，国外访问的时候解析到 Github，访问效率和文章收录就全部都搞定了。 为什么要提交文章到 Baidu 和 Google 收录呢，因为如果不提交的话通过对应的搜索引擎是搜索不到你的文章的，别人没法看到。提交收录成功后等待一段（大概15天左右，Google 会快些）就可以在晚上搜到你的文章了，我以 Baidu 和 Google 为例，记录下提交 Hexo 文章到 搜索引擎收录的方法。 收录情况打开浏览器的输入 site:www.xxx.com 即可查询，如果没有搜索到对应内容，就表示没有收录。 验证网站网站验证目的是为了证明你是该网站的持有者，分别登录到 Google Search Console 和 百度站长资源管理平台 添加你的域名，然后一步一步验证就好。 方法一般分为 HTML 文件验证、HTML 标签验证、CNAME 验证等，其实就是一串类似于 RTIrgNNg7m 的密钥，将其放在你的网站主页就好，网站上写的都比较详细，就不再记录了。 站点配置打开 Hexo 博客站点配置文件，添加以下两行。12google_site_verification: xxxxxxxbaidu-site-verification: xxxxxxx 执行编译命令 hexo d -g 。 注意 Google 的符号是 _，而百度为 -，其中 xxxxxxx 为在两个网站上获取的 HTML 标签内容。(即密钥) 添加站点地图首先安装站点地图生成插件，打开终端分别输入以下命令。12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 在博客的 站点配置文件 _config.yml 中添加以下代码。12345# 自动生成sitemapsitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 再次执行编译命令 hexo d -g 。这时候在博客的public文件夹下面就会出现站点地图 sitemap.xml 和 baidusitemap.xml 了。 这里有一点需要注意，打开两个站点地图文件，会发现里面的网址全部是 http://yoursite.com/，不是我们自己的域名，这样显然是不性的。打开 站点配置文件 _config.yml 搜索 url: 字段，将 http://yoursite.com/ 替换成你的域名，然后重新 hexo d -g 编译部署即可。 提交站点地图经过上面的配置后，回到Google Search Console 和 百度站长资源管理平台 ，选择提交 Sitemap，按照示例的格式提交即可。 提交完成后如果没有报错显示正常就代表提交成功了，但短时间内还是无法搜索到你的博客的，接下来等搜索抓取收录即可。另外 Baidu 和 Google 都是可以配置自动提交的（手动效率最高），按照网站上的方法一步一步操作就好。还有如果你和我一样用的是 Next 主题，只需要将 主题配置文件 中的 baidu_push 设置为 true，就可以完成百度自动推送了。 关于网站 seo 这一块的内容还是很多的，如果维护好自己的站点看似简单其实也是很复杂的，就先写到这里，有时间的话会继续更新一些进阶的 seo 优化方法。待续……]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo Next 主题的优化]]></title>
    <url>%2F2018%2F01%2F12%2F2018%2FHexo-next-theme-optimization%2F</url>
    <content type="text"><![CDATA[基础框架全部搭好之后，自然就是关于一些优化和个性化的事情了。关于 Next 主题的优化，如设置主题样式、字体、头像、第三方统计、评论、分享等在 NexT 使用文档 里都有极详细的介绍，这里不一一介绍了。只记录一些文档中没有提及的点。 第三方推荐搜索：Local Search 简单方便，安装即可使用。统计：不蒜子统计，简单易用推荐使用。评论：来必力评论，目前好像也只有这个可用了，之前还用过多说评论和网易云跟帖。 侧边栏社交小图标设置打开主题配置文件 _config.yml 搜索 social:，在 图标库 找自己喜欢的小图标，并将名字复制在对应的 || 后，保存即可： 1234social: GitHub: https://github.com/Lewanny || github 微博: https://weibo.com/u/2951067307 || weibo 简书: https://www.jianshu.com/users/f0040a970739 || heartbeat 添加 about 页面进入到博客根目录下，执行以下命令： $ hexo new page &quot;about&quot; 完成后会在 /source/about 目录下生成一个 index.md 文件。打开 index.md 文件，在 data 下添加 type: &quot;about&quot;，然后编辑自己想要展示的内容即可。（注意将主题配置文件中的 menu: about 页面打开）。 添加网易云音乐播放使用 iframe 标签播放即可。 &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; width=&quot;300&quot; height=&quot;86&quot; src=&quot;https://music.163.com/outchain/player?type=2&amp;id=5253801&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt; // 到网易云中复制即可 如果想放在侧栏里面播放，将代码 加入到 hexo/themes/next/layout/_macro 目录中的 sidebar.swig 文件中即可。位置如下： 设置网站的 Favicon 图标准备一个常见格式名(如.jpg、.png等)的图片作为备选 favicon，选择一个 favicon 制作网站完成制作，例如：比特虫。 如下修改主题配置文件即可：12345favicon: small: /images/favicon_16x16.ico medium: /images/favicon_32x32.ico apple_touch_icon: /images/favicon_128x128.ico safari_pinned_tab: /images/favicon_128x128.ico 未完待续]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用 Hexo 搭建个人博客并部署到 Github Page]]></title>
    <url>%2F2018%2F01%2F11%2F2018%2FHexo-build-yourown-blog-with-hexo%2F</url>
    <content type="text"><![CDATA[前段时间由于电脑突然故障，导致所有本地数据全部丢失，所以不得不重新把个人博客搭起来。还好当时把博客分别部署到了 Coding 和 Github，省去了一些麻烦事，只是 md 文件都要重新写一遍了。这里重新记录下相关的过程。有备无患，后面有时间的话会陆续总结先优化为、同时部署到Coding 和 Github 、提交百度、Google 收录、SEO 搜索等。 Hexo 是一个快速、简洁且高效的博客框架。而 Github 是一个免费的代码托管工具，利用 Github Page 可以免费创建一个静态网站。下面将介绍如何使用 Hexo 和 Github，在 mac 环境下搭建静态博客。 Hexo 环境配置Node.js用来生成静态页面，可到 Node.js 官网 下载推荐版本，默认配置一路安装即可。 Git用来将本地 Hexo 内容提交到 Github 上。Xcode 自带 Git。如果没有 Xcode 可以参考 Git 官网 下载安装。 安装 HexoNode.js 和 Git 都安装好后就可以正式安装 Hexo 了，终端执行如下命令： $ sudo npm install -g hexo sudo:linux 系统管理指令 -g:全局安装 初始化 Hexo，终端 cd 到一个你选定的目录，执行 hexo init 命令： $ hexo init blog blog 是你建立的文件夹名称。 cd 到 blog 文件夹下，执行如下命令，安装 npm： $ npm install 执行如下命令，开启 Hexo 服务器（结束为 control+c）： $ hexo s 此时，浏览器中打开网址 http://localhost:4000，如果能看到如下页面，Hexo 本地初始化即完成： 关联到 Github添加 ssh key 到 Github检查 SSH keys 是否存在 Github执行如下命令，检查 SSH keys 是否存在。如果有文件 id_rsa.pub 或 id_dsa.pub ，则直接进入步骤 1.3 将 SSH key 添加到 Github 中，否则进入下一步生成 SSH key。 $ ls -al ~/.ssh 生成新的 ssh key执行如下命令生成 public/private rsa key pair，注意将 your_email@example.com 换成你自己注册 Github 的邮箱地址。、 $ ssh-keygen -t rsa -C &quot;your_email@example.com&quot; 接下来会提示输入密码路径，按 3 次回车，密码为空。最后会在相应路径下（~/.ssh/id_rsa.pub）生成 d_rsa 和 id_rsa.pub 两个文件。 将 ssh key 添加到 Github 中Finder 前往文件夹 ~/.ssh/id_rsa.pub 打开 id_rsa.pub 文件，里面的信息即为 SSH key，将这些信息复制到 Github 的 Add SSH key 页面即可。 进入Github –&gt; Settings –&gt; SSH keys –&gt; add SSH key，Title 任意，将复制的内容粘贴到 Key 里，点击 Add key 按钮即可。 创建仓库登录 Github 帐号，新建仓库，命名必须为 用户名.github.io 固定写法，如Lewanny.github.io,如下图所示： 本地的 blog 文件夹下内容为： 配置文件打开 _config.yml 文件，里面是博客的主体配置项，找到 deploy: 配置，修改如下：1234deploy: type: git repository: https://github.com/Lewanny/Lewanny.github.io.git branch: master 注意：在配置所有的 _config.yml 文件时（包括 theme）时，在所有的冒号 : 后边都要加一个空格，否则执行 hexo 命令会报错。 部署文件生成静态页面命令在 blog 文件夹目录下执行生成静态页面命令： $ hexo g // 或者：hexo generate 此时若出现如下报错：1 ERROR Local hexo not found in ~/blog 2 ERROR Try runing: &#39;npm install hexo --save&#39;则执行命令：npm install hexo --save 配置命令再执行配置命令： $ hexo d // 或者：hexo deploy 若执行命令 hexo deploy 仍然报错：ERROR Deployer not found: git。则执行如下命令来安装 hexo-deployer-git： npm install --save hexo-deployer-git 再次执行 hexo generate 和 hexo deploy 命令 (或 hexo d -g，即部署前先生成静态界面) 即可完成 Github 关联。此时，浏览器中打开网址 https://lewanny.github.io（注意将 username 替换）能看到和打开 http://localhost:4000 时一样的页面。 安装 Theme可以到 Hexo 官网主题页 去搜寻自己喜欢的 theme。这里以 hexo-theme-next 为例，Next 官网。 终端 cd 到 blog 目录下执行如下命令： $ git clone https://github.com/iissnan/hexo-theme-next themes/next 将 blog 目录下 _config.yml 里 theme 的名称 landscape 修改为 next 即可。 终端 cd 到 blog 目录下执行如下命令(每次部署文章的步骤)：12$ hexo clean // 清除缓存文件 (db.json) 和已生成的静态文件 (public)$ hexo d -g // 生成缓存和静态文件并重新部署到服务器 至于更改 theme 内容，比如名称，描述，头像等去修改 blog/_config.yml 文件和 blog/themes/next/_config.yml 文件中对应的属性名称即可， 不要忘记冒号:后加空格。NexT 使用文档里有极详细的介绍。 发表文章终端 cd 到 blog 文件夹下，执行如下命令新建文章： hexo new &quot;postName&quot; // postName为文章名字 名为 postName.md 的文件会建在目录 /blog/source/_posts 下。你当然可以用 vim 来编辑文章，这里推荐使用 MacDown。 文章编辑完成后，终端 cd 到 blog 文件夹下，执行如下命令来发布：12hexo generate // 生成静态页面hexo deploy // 将文章部署到 Github // 或 hexo d -g 至此，使用 Hexo 搭建个人博客并部署到 GitHub 就基本完成了。后面会陆续更新出如何绑定独立域名、next 主题的优化和功能配置、同时部署博客到 GitHub 和 Coding、提交文章到百度谷歌收录、备份博客等（防止悲剧重演…）。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 使用 Quart2D 绘图基础]]></title>
    <url>%2F2017%2F05%2F15%2F2017%2FiOS-basic-mapping-usage-with-Quart2D%2F</url>
    <content type="text"><![CDATA[Quartz 2D 是⼀个二维绘图引擎，同时支持 iOS 和 Mac 平台。 Quartz 2D 能够绘制图形、绘制文字、绘制\生成图片、读取\生成PDF、截图\裁剪图片等。其实，iOS 中⼤部分控件的内容都是通过 Quartz2D 画出来的，因此Quartz2D 在 iOS 开发中很重要的⼀个价值就是自定义 UI 控件)。 在 Mac OS X 中，Quartz 2D 可以与其它图形图像技术混合使用，如 Core Image、Core Video、OpenGL、QuickTime。例如，通过使用 QuickTime 的 GraphicsImportCreateCGImage 函数，可以用 Quartz 从一个 QuickTime 图形导入器中创建一个图像。 基础准备简介Quartz2D 的 API 是纯 C 语⾔的，它的 API 来自于 Core Graphics 框架。数据类型和函数基本都以 CG 作为前缀，例如 CGContextRef、CGPathRef、CGContextStrokePath() 等。 图形上下文图形上下文 (Graphics Context) 是一个 CGContextRef 类型的数据。图形上下文可以保存绘图信息、绘图状态、决定绘制的输出目标（PDF 文件、Bitmap 窗口等）。 drawRect 方法12345-[viewController loadView]-[viewController viewDidLoad]-[viewController viewWillAppear:]-[viewController drawRect:]-[viewController viewDidAppear:] 在 drawRect: 方法中取得上下文后，就可以绘制东西到 view 上，view 内部有个 layer(图层) 属性，drawRect: 方法中取得的是 Layer Graphics Context ，因此绘制的东西其实是绘制到 layer 上面。view 之所以能显示东西，也完全是因为它内部的 layer 。 绘制步骤 创建一个 UIView 的子类，重写这个类的 - (void)drawRect:(CGRect)rect 方法。 UIGraphicsGetCurrentContext() 获取当前的上下文（这里只能获取一次，并且只能在 drawRect 方法中获取） 描述路径、形状（就是处理想要显示的样子） 把描述好的路径、形状添加早上下文中 CGContextAddPath()。 显示上下文内容。 画线两点确定一条直线，先确定线的起点，然后确定终点，绘制出路径就 ok 了。1234567891011121314151617181920#pragma mark - 画线- (void)drawRect:(CGRect)rect &#123; NSLog(@"%s",__func__); // 1.获取上下文 CGContextRef contextRef = UIGraphicsGetCurrentContext(); // 2.路径描述 UIBezierPath *linePath = [UIBezierPath bezierPath]; [linePath moveToPoint:CGPointMake(0, 0)]; // 起点 [linePath addLineToPoint:CGPointMake(WIDTH, HEIGHT)]; // 终点 [[UIColor blackColor] setStroke]; // 设置颜色 CGContextSetLineWidth(contextRef, 5); // 设置线宽 // 3.添加路径 CGContextAddPath(contextRef, linePath.CGPath); // 4.显示路径 CGContextStrokePath(contextRef);&#125; 画矩形绘制矩形，却要确定它的四个顶点和四条线，方法一。1234567891011121314151617181920#pragma mark - 画矩形- (void)drawRect:(CGRect)rect &#123; // 1.获取上下文 CGContextRef contextRef = UIGraphicsGetCurrentContext(); // 2.描述路径 UIBezierPath *rectPath = [UIBezierPath bezierPath]; [rectPath moveToPoint:CGPointMake(30, 30)]; // 第一个点 [rectPath addLineToPoint:CGPointMake(WIDTH-60, 30)]; // 第二个点 [rectPath addLineToPoint:CGPointMake(WIDTH-60, HEIGHT-60)]; // 第三个点 [rectPath addLineToPoint:CGPointMake(30, HEIGHT-60)]; // 第四个点 [rectPath closePath]; // 闭合路径，同 [rectPath addLineToPoint:CGPointMake(30, 30)]; [[UIColor blackColor] setStroke]; // 设置颜色 // 3.添加路径 CGContextAddPath(contextRef, rectPath.CGPath); // 4.显示路径 CGContextStrokePath(contextRef);&#125; 方法二。123456789101112- (void)drawRect:(CGRect)rect &#123; // 1.获取上下文 CGContextRef contextRef = UIGraphicsGetCurrentContext(); // 2.描述路径 UIBezierPath *rectPath = [UIBezierPath bezierPathWithRect:CGRectMake(30, 30, WIDTH-60, HEIGHT-60)]; // 路径 [[UIColor blackColor] setFill]; // 颜色 // 3.添加、显示路径 CGContextAddPath(contextRef, rectPath.CGPath); CGContextFillPath(contextRef);&#125; 1234[[UIColor greenColor] setStroke]; // 设置描边颜色CGContextStrokePath(contextRef); // 显示描边路径[[UIColor greenColor] set]; // 设置填充颜色CGContextFillPath(contextRef); // 显示填充路径 画圆第一种画圆思路需要确定圆形的圆心点、半径以及旋转角度。12345678910111213#pragma mark - 画圆- (void)drawRect:(CGRect)rect &#123; // 1、获取当前上下文 CGContextRef contextRef = UIGraphicsGetCurrentContext(); // 2. 描述路径 -&gt; ArcCenter:中心点 / radius:半径 / startAngle：起始角度 / endAngle：结束角度 / clockwise：是否逆时针 UIBezierPath *circlePath = [UIBezierPath bezierPathWithArcCenter:CGPointMake(WIDTH/2, HEIGHT/2) radius:120 startAngle:0 endAngle:M_PI*2 clockwise:YES]; [[UIColor blackColor] setFill]; //颜色 // 3. 填充显示上下文 CGContextAddPath(contextRef, circlePath.CGPath); CGContextFillPath(contextRef); // 空心圆使用 CGContextStrokePath&#125; 第二种方法利用画椭圆的方法，圆形是特殊的椭圆形。1234567891011- (void)drawRect:(CGRect)rect &#123; // 1、获取当前上下文 CGContextRef contextRef =UIGraphicsGetCurrentContext(); //2. 描述路径，画椭圆的方法 UIBezierPath *ovalePath = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(30, 30, 200, 200)]; // 3. 填充显示上下文 CGContextAddPath(contextRef, ovalePath.CGPath); CGContextStrokePath(contextRef);&#125; 扇形扇形是圆形的一部分。12345678910111213141516171819202122232425262728293031323334// 计算度转弧度static inline float radians(double degrees) &#123; return degrees * M_PI / 180;&#125;static inline void drawArc(CGContextRef ctx, CGPoint point, float angle_start, float angle_end, UIColor* color,float radius) &#123; CGContextMoveToPoint(ctx, point.x, point.y); CGContextSetFillColor(ctx, CGColorGetComponents( [color CGColor])); CGContextAddArc(ctx, point.x, point.y, radius, angle_start, angle_end, 0); //CGContextClosePath(ctx); CGContextFillPath(ctx);&#125;-(void)drawRect:(CGRect)rect &#123; CGPoint cent = CGPointMake(WIDTH/2, HEIGHT/2); CGContextRef ctx = UIGraphicsGetCurrentContext(); CGContextClearRect(ctx, rect); float angle_start = radians(0.0); float angle_end = radians(121.0); drawArc(ctx, cent, angle_start, angle_end, [UIColor blueColor], _radius); angle_start = angle_end; angle_end = radians(228.0); drawArc(ctx, cent, angle_start, angle_end, [UIColor greenColor], _radius); angle_start = angle_end; angle_end = radians(260); drawArc(ctx, cent, angle_start, angle_end, [UIColor orangeColor], _radius); angle_start = angle_end; angle_end = radians(360); drawArc(ctx, cent, angle_start, angle_end, [UIColor purpleColor], _radius);&#125; 如果需要更新角度或者颜色等，需要在更新的地方调用 [self setNeedsDisplay]; 即可。 画文字简单绘制。123456789- (void)drawRect:(CGRect)rect &#123; CGContextRef contextRef =UIGraphicsGetCurrentContext(); // 绘制文字，默认从 (0,0) 开始 NSString *norText = @"我是普通文字"; [norText drawInRect:rect withAttributes:nil]; CGContextStrokePath(contextRef);&#125; 其他的设置。123456789101112131415161718192021222324- (void)drawRect:(CGRect)rect &#123; CGContextRef contextRef = UIGraphicsGetCurrentContext(); // 字体设置 NSString *text = @"艺术字体"; NSMutableDictionary * dict = [NSMutableDictionary dictionary]; dict[NSFontAttributeName] = [UIFont systemFontOfSize:32]; // 字体大小 dict[NSForegroundColorAttributeName] = [UIColor blueColor]; // 字体前景色 dict[NSBackgroundColorAttributeName] = [UIColor blackColor]; // 字体背景色 //字体阴影 NSShadow * shadow = [[NSShadow alloc] init]; shadow.shadowOffset = CGSizeMake(2, 2); // 阴影偏移量 shadow.shadowColor = [UIColor orangeColor]; // 阴影颜色 shadow.shadowBlurRadius = 5; // 高斯模糊 dict[NSShadowAttributeName] = shadow; //字体间距 dict[NSKernAttributeName] = @10; // 从某一点开始绘制 [text drawAtPoint:CGPointMake(80, 100) withAttributes:dict]; CGContextStrokePath(contextRef);&#125; 画图片12345678910111213141516171819#pragma mark - 画图片- (void)drawRect:(CGRect)rect &#123; CGContextRef contextRef = UIGraphicsGetCurrentContext(); UIImage *image = [UIImage imageNamed:@"avatar"]; // 直接绘制// [image drawInRect:rect]; // 从某个点开始绘制// [image drawAtPoint:CGPointMake(60, 60)]; //从某一点开始绘制图片，并且设置混合模式以及透明度// [image drawAtPoint:CGPointMake(0, 0) blendMode:kCGBlendModeNormal alpha:1]; // 绘制图片的大小，并且设置混合模式以及透明度 [image drawInRect:CGRectMake(30, 30, WIDTH-60, HEIGHT-60) blendMode:kCGBlendModeNormal alpha:1]; CGContextFillPath(contextRef);&#125; 进度条123456789- (void)drawRect:(CGRect)rect &#123; CGFloat startA = -M_PI_2; CGFloat endA = -M_PI_2 + self.progress.value* M_PI*2; UIBezierPath * path = [UIBezierPath bezierPathWithArcCenter:CGPointMake(self.bounds.size.width*0.5, self.bounds.size.height*0.5) radius:self.bounds.size.width*0.3-10 startAngle:startA endAngle:endA clockwise:YES]; [path moveToPoint:CGPointMake(30, 30)]; [[UIColor colorWithRed:0 green:(1-self.progress.value) blue:self.progress.value alpha:1]setStroke]; path.lineWidth = 5.0f; [path stroke];&#125; 如何绘制三条不同颜色的线方法一。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051- (void)drawRect:(CGRect)rect &#123; //1 获取上下文 //分别设置线段的颜色 CGContextRef purple = UIGraphicsGetCurrentContext(); [[UIColor purpleColor]setStroke]; CGContextSaveGState(purple); CGContextRef orange = UIGraphicsGetCurrentContext(); [[UIColor orangeColor]setStroke]; CGContextSaveGState(orange); CGContextRef green = UIGraphicsGetCurrentContext(); [[UIColor greenColor]setStroke]; CGContextSaveGState(green); UIBezierPath * path = [UIBezierPath bezierPath]; //设置线宽 path.lineWidth = 5; //把紫色的上下文从栈中取出来 CGContextRestoreGState(purple); //第一条线 [[UIColor purpleColor]setStroke]; [path moveToPoint:CGPointMake(10, 10)]; [path addLineToPoint:CGPointMake(10, 100)]; [path stroke]; //把紫色的上下文从栈中取出来 CGContextRestoreGState(orange); path = [UIBezierPath bezierPath]; //设置线宽 path.lineWidth = 9; //第二条线 [[UIColor orangeColor]setStroke]; [path moveToPoint:CGPointMake(30, 10)]; [path addLineToPoint:CGPointMake(30, 100)]; [path stroke]; //把紫色的上下文从栈中取出来 CGContextRestoreGState(green); path = [UIBezierPath bezierPath]; //设置线宽 path.lineWidth = 3; //第三条线 [[UIColor greenColor]setStroke]; [path moveToPoint:CGPointMake(50, 10)]; [path addLineToPoint:CGPointMake(50, 100)]; [path stroke];&#125; 方法二。1234567891011121314- (void)drawRect:(CGRect)rect &#123; [[self bezierPathWithPoint:CGPointMake(10, 10) endPoint:CGPointMake(10, 180) lineColor:[UIColor purpleColor] lineWidth:6] stroke]; [[self bezierPathWithPoint:CGPointMake(50, 10) endPoint:CGPointMake(50, 180) lineColor:[UIColor greenColor] lineWidth:6] stroke]; [[self bezierPathWithPoint:CGPointMake(90, 10) endPoint:CGPointMake(90, 180) lineColor:[UIColor orangeColor] lineWidth:6] stroke];&#125;- (UIBezierPath *)bezierPathWithPoint:(CGPoint)startPoint endPoint:(CGPoint) endPoint lineColor:(UIColor*)lineColor lineWidth:(CGFloat)lineWidth&#123; UIBezierPath * path = [UIBezierPath bezierPath]; [lineColor setStroke]; path.lineWidth = lineWidth; [path moveToPoint:startPoint]; [path addLineToPoint:endPoint]; return path;&#125; 渐变色方法一。123456789101112131415- (void)drawRect:(CGRect)rect &#123; CAGradientLayer * layer = [CAGradientLayer layer]; // 设置大小 layer.frame = CGRectMake(0, 400, 300, 3); // 设置颜色 layer.colors = @[(__bridge id)[UIColor colorWithRed:204.0 / 255.0 green:224.0 / 255.0 blue:244.0 / 255.0 alpha:1].CGColor, (__bridge id)[UIColor colorWithRed:29.0 / 255.0 green:156.0 / 255.0 blue:215.0 / 255.0 alpha:1].CGColor, (__bridge id)[UIColor colorWithRed:255.0 / 255.0 green:50.0 / 255.0 blue:126.0 / 255.0 alpha:1].CGColor]; // 渐变层的相对位置,起始点为0,终止点为1,中间点为 (point-startpoint)/(endpoint-startpoint) layer.locations = @[@0,@.5,@1]; // 渐变方向 layer.startPoint = CGPointMake(0, 1); layer.endPoint = CGPointMake(1, 1); [self.layer addSublayer:layer];&#125; 方法二。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152- (void)drawRect:(CGRect)rect &#123; [self drawLine]; [self drawLineWithStartColor:[UIColor redColor] endColor:[UIColor greenColor]];&#125;- (void)drawLineWithStartColor:(UIColor *)startColor endColor:(UIColor *)endColor&#123; CGContextRef ctx = UIGraphicsGetCurrentContext(); // 创建颜色空间 CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB(); CGFloat locations[] = &#123; 0.0, 1.0 &#125;; // 创建颜色数组，NSArray 只能存储 OC 对象，所以需要桥接 NSArray *colors = @[(__bridge id)startColor.CGColor,(__bridge id)endColor.CGColor]; CGGradientRef gradient = CGGradientCreateWithColors(colorSpace, (__bridge CFArrayRef) colors, locations); //释放 CFRelease(colorSpace); // 保存一份当前上下文，压栈 CGContextSaveGState(ctx); CGFloat width = self.frame.size.width; CGContextMoveToPoint(ctx, 0, 120); CGContextAddLineToPoint(ctx, width, 120); CGContextAddLineToPoint(ctx, width, 123); CGContextAddLineToPoint(ctx, 0, 123); //裁剪 CGContextEOClip(ctx); //绘制渐变 CGContextDrawLinearGradient(ctx, gradient, CGPointMake(0, 100), CGPointMake(self.frame.size.width, 100), kCGGradientDrawsBeforeStartLocation); //恢复一份当前的上下文，出栈 CGContextRestoreGState(ctx); CGColorSpaceRelease(colorSpace); CGGradientRelease(gradient);&#125;- (void)drawLine&#123; // 获取上下文 CGContextRef ctx = UIGraphicsGetCurrentContext(); CGContextMoveToPoint(ctx, 0, 100); CGContextAddLineToPoint(ctx, 300, 100); CGContextSetLineWidth(ctx, 3); // 填充路径 CGContextStrokePath(ctx); // 释放 CGContextRelease(ctx);&#125;]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[总结下 iOS 蓝牙开发中常用的数据转换]]></title>
    <url>%2F2017%2F04%2F16%2F2017%2FiOS-bluetooth-summary-of-data-conversion%2F</url>
    <content type="text"><![CDATA[蓝牙开发有一段时间了，处理蓝牙数据的时候，经常遇到进制之间的转换，蓝牙处理的是十六进制（NSData），有时也会把十六进制拆成二进制记录。这里总结下蓝牙开发中常用的进行转换和数据转换。 十进制转换二进制1234567891011121314151617// int 转二进制字符串- (NSString *)convertIntToBinaryWithInt: (int)intValue&#123; int byteBlock = 8, // 8 bits per byte totalBits = (sizeof(int)) * byteBlock, binaryDigit = totalBits; char ndigit[totalBits + 1]; while (binaryDigit-- &gt; 0) &#123; ndigit[binaryDigit] = (intValue &amp; 1) ? '1' : '0'; intValue &gt;&gt;= 1; &#125; ndigit[totalBits] = 0; NSString *str = [NSString stringWithUTF8String: ndigit]; return [str substringWithRange: NSMakeRange(str.length - 8, 8)];&#125; 二进制转换十进制1234567891011121314// 二进制转十进制- (NSString *)convertBinaryToIntWithBinary:(NSString *)binary&#123; int subBinary = 0 ; int temp = 0 ; for (int i = 0; i &lt; binary.length; i ++) &#123; temp = [[binary substringWithRange:NSMakeRange(i, 1)] intValue]; temp = temp * powf(2, binary.length - i - 1); subBinary += temp; &#125; NSString * result = [NSString stringWithFormat:@"%d",subBinary]; return result;&#125; 有点忙，待续….]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS 开发使用 TestFlight 进行 Beta 测试]]></title>
    <url>%2F2017%2F03%2F20%2F2017%2FiOS-beta-test-with-TestFlight%2F</url>
    <content type="text"><![CDATA[应用开发过程中 Beta 测试是必须的。TestFlight 就是用于 Beta 版测试的。不同与较老的 adhoc 测试包方法，TestFlight 不需要测试人员的设备 UDID，也没有 100 台设备的上限。目前 TestFlight 已经被苹果收购，需要 iOS8 及以上版本的 iOS 设备才能运行。TestFlight 整合进了 iTunes Connect，开发者可以通过电子邮件来邀请测试员来进行测试，这样开发者就可以更简单地让你的同行非同行、你的上级、你的客户、你所想要一起参与测试的人一起来测试应用。 什么是 TestFlightTestFlight 的测试方式分为内部测试和外部测试两种，从功能上讲，这两种方式都可以为测试人员在测试阶段对你的 App 进行测试。 内部测试所谓的内部主要是指 iTunes Connect 上 在你的开发团队里参与技术开发或者管理的成员。最多可以邀请 25 个内部成员。无审核限制，也就是说只要你把你的 App 上传到 iTunes Connect 上之后内部成员就可以开始进行内部测试了，无需审核。在邀请发出后，有效测试时间为 90 天。 外部测试而与之相对的外部测试，指的是那些不属于你的团队或者公司的测试者，外部测试人员的上限是 2000 人，但在你邀请外部成员参与测试之前，需要先通过苹果的审核，一般审核会在一天左右。而这一限制在内部成员上就没有。在邀请发出后，有效测试时间为 60 天。 TestFlight 的优势 老旧的 Adhoc 测试包方法需要供参与 app 测试人员的设备 UDID，并且开发者需要将这些设备的 UDID 添加到开发者中心，每次有新的测试人员加入，需要重新生成 profiles，重新打包，而且只能添加100台设备的限制，TestFlight 这方面限制较小。 TestFlight 测试只需要参与 app 测试人员提供一个邮箱，开发者登录 iTunes Connect，给测试者发送邀请，测试者接受邀请，然后通过 TestFlight 应用，下载安装程序。不再次需要用户提供设备的 UDID，最重要的一点是没有了 100 台设备的限制，一般内部测试人员最多 25 个人，外部测试人员最多 2000 个人，也不需要每次都重新配置证书，不需要每次都手动发送 ipa 包, 直接上传到 iTunes 即可。 当然也可使用蒲公英等其他方法参与测试。 如何使用 TestFlight创建应用 进入 iTunes Connect 网址：iTunes Connect ，输入账号密码登录至 iTunes Connect。 登陆成功后点击 MyApp 进入到应用列表。 如果是初次创建的 App，需要创建一个 iTunes Connect Record。如果你的 App 已经创建好了，可以直接跳过这段，如果你要新建一个 App 的话，可以按照下面的步骤来做。 如何创建应用 登录 iTunes Connect 。在 iTunes Connect 的首页，点击 My Apps 图标。 点击 + 号按钮，创建一个新的应用。 填写好如下弹窗内的信息，点击创建按钮完成创建即可，刚刚创建好的应用便会显示在 My App 列表中。 提交 App 到 iTunes Connect。在 Xcode 中配置好版本和证书信息。选中 菜单 -&gt; Product -&gt;Archive 将当前代码归档。归档完成后选择 Organizer -&gt; Archives -&gt; Validate 按钮来检测该归档文件是否符合要求。验证通过之后，你可以选择 Submit 来提交这个归档至 iTunes Connect。注意：提交的包必须是 App Store 包。 每当你提交一个新的 build 之后，在 iTunes Connect 的列表中都会对应的增加一个 build。 邀请 TestFlight 测试人员 选择 TestFlight，在 TestFlight 中填写基本信息接收反馈的邮箱地址，隐私政策网址等，然后构建好需要测试的版本信息。 按照提示才操作来邀请你的测试人员（分内部和外部，其中 iTunes Connect 为内部）。 填写好对应测试人员的邮箱，发送好对应邮件即可。测试人员需在 App Store 中下载 TestFlight，之后会收到两封邮件，一封是邀请你加入测试组的邮件，点击同意即可，另一封是成功加入测试组的通知，点击 start testing 然后跳转到有加粗黑色字体的8个字母测试码的页面，然后点击 Redeem，输入这8个字母即可下载测试app。（现在会直接跳转。） 开发者发布新的版本测试人员可直接在 TestFlight 查看对应版本即可。 另外 TestFlight 还有很多其他的功能和用途，还是挺不错的，这里不再一一记录了。具体可登陆 iTunes Connect 查看。]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>TestFlight</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML+CSS 学习笔记 - CSS 基本样式与布局]]></title>
    <url>%2F2017%2F02%2F18%2F2017%2FHTML-CSS-learn-note-part02-css-style-layout%2F</url>
    <content type="text"><![CDATA[使用 CSS 样式的一个好处是通过定义某个样式，可以让不同网页位置的文字有着统一的字体、字号或者颜色等。本文代码传送。 CSS，为网页添加样式认识 CSS 样式CSS 全称为 “层叠样式表 (Cascading Style Sheets)”，它主要是用于定义 HTML 内容在浏览器内的显示样式，如文字大小、颜色、字体加粗等。 例如如下代码：12345p &#123; font-size:12px; color:red; font-weight:blod;&#125; CSS样式的优势就是只需要一条 CSS 代码即可设置网页样式。 CSS 代码语法CSS 样式由选择符和声明组成，而声明又由属性和值组成，如下所示： 选择符：又称为选择器，知名网页中需要样式的元素，其他的元素则不会受到影响声明：在英文的 {} 之中的便是声明，属性和值之间用英文的 : 隔开。多条声明时，之间用 ; 隔开。1234p &#123; font-size:12px; color:red; &#125; 注意：最后一条可以不加 ; ，但是为了方便修改也为了规范，也加上 ; 。为了代码更便于阅读，如上，每一条属性各占一行。 CSS 代码注释CSS 中的注释样式为 /*注释文字*/ ，Html 中使用 &lt;!--注释文字--&gt; 来注释。 CSS 的基本样式CSS 样式从插入代码的形式分为三种：内联式、嵌入式和外部式。 内联 css 样式，直接写在 HTML 标签内内联式直接把 css 代码写在 HTML 标签中，注意要写在开始标签，而不是结束标签。内联 css 要写在 style=””中，多条样式代码设置可写在一起，中间用 ; 隔开。如下所示：1&lt;p style="color:red;font-size:12px"&gt;红色十二号字体&lt;p&gt; 嵌入式 css 样式，写在当前的文件中嵌入式 css 样式，就是把 css 样式代码写在 标签之间。嵌入式 css 样式必须写在 之间，并且一般在 之间。它较内联式的好处可以为相同的标签设置同样的样式，是不用为每个标签单独的写样式代码。123456789101112&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;&lt;title&gt;嵌入式css样式&lt;/title&gt;&lt;style type="text/css"&gt; span&#123;font-size:18; color:green&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;&lt;span&gt;嵌入式&lt;/span&gt;较内联式的好处可以为相同的标签&lt;span&gt;设置同样的样式&lt;/span&gt;，是不用为&lt;span&gt;每个标签&lt;/span&gt;单独的写样式代码。&lt;p&gt;&lt;/body&gt;&lt;/html&gt; 外部式 css 样式，写在单独的文件中外部式 css 样式(外联式)就是把 css 代码写一个单独的外部文件中，这个 css 样式文件以 “.css” 为扩展名，在 内使用 标签将 css 样式文件链接到 HTML 文件内，如下面代码：123456&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;&lt;title&gt;嵌入式css样式&lt;/title&gt;&lt;link href="style.css" rel="stylesheet" type="text/css" /&gt;&lt;/head&gt;&lt;&gt; 12345/*style.css 文件中的代码*/span&#123; color:red; font-size:20px;&#125; 注意：1、css 样式文件命名应该有意义，如 main.css 。2、rel=”stylesheet” type=”text/css” 是固定写法不可修改。3、link 的位置一般写在标签内。]]></content>
      <categories>
        <category>HTML+CSS</category>
      </categories>
      <tags>
        <tag>HTML+CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML+CSS 学习笔记 - 标签部分]]></title>
    <url>%2F2017%2F02%2F09%2F2017%2FHTML-CSS-learn-note-part01-label%2F</url>
    <content type="text"><![CDATA[学习 web 前端开发技术需要掌握：HTML、CSS 和 JavaScript 语言。其中，HTML 是网页内容的载体，就是页面上的信息，包括文字、图片、视频等。CSS 样式是表现，如标题颜色、背景颜色、背景图、边框等。JavaScript 用来实现网页上的特效效果，如鼠标滑过的下拉菜单和动画等交互都是用 JavaScript 实现的。 IDE 推荐 Adobe 前端神器 Brackets ，简单易用。 下面是学习 HTML+CSS 的学习笔记。本文的源码地址传送门。 标签简介什么是标签 标签由英文尖括号 &lt; 和 &gt; 括起来，如 &lt;html&gt; 就是一个标签。 html 中的标签一般都是成对出现的，分开始标签和结束标签。结束标签比开始标签多了一个 / 。 标签之间是可以嵌套的，如： 1&lt;div&gt;&lt;p&gt; &lt;/p&gt;&lt;/div&gt; HTML 标签不区分大小写，如 &lt;h1&gt; 和 &lt;H1&gt; 是一样的，以小写为准。 可以说我们平时看到的各种各样的网页都是由 HTML 标签 组成的。如下面的这个例子。123456789101112&lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt; &lt;title&gt;认识html标签&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;勇气哈哈&lt;/h2&gt; &lt;p&gt;三年级时，我还是一个胆小如鼠的小女孩，上课从来不敢回答老师提出的问题，生怕回答错了老师会批评我。就一直没有这个勇气来回答老师提出的问题。学校举办的活动我也没勇气参加。&lt;/p&gt; &lt;p&gt;到了三年级下学期时，我们班上了一节公开课，老师提出了一个很简单的问题，班里很多同学都举手了，甚至成绩比我差很多的，也举手了，还说着："我来，我来。"我环顾了四周，就我没有举手。&lt;/p&gt; &lt;img src="http://img.mukewang.com/52b4113500018cf102000200.jpg" &gt; &lt;/body&gt;&lt;/html&gt; html 文件的结构一个HTML文件是有自己固定的结构的。1234&lt;html&gt; &lt;head&gt;...&lt;/head&gt; &lt;body&gt;...&lt;/body&gt;&lt;/html&gt; 称为根标签，所有的网页标签都在根标签中。 标签用于定义文档的头部，它是所有头部元素的容器。头部元素有 &lt;title&gt;、&lt;script&gt;、 &lt;style&gt;、&lt;link&gt;、 &lt;meta&gt; 等标签，头部标签在下一小节中会有详细介绍。 在 和 标签之间的内容是网页的主要内容，如 &lt;h1&gt;、&lt;p&gt;、&lt;a&gt;、&lt;img&gt; 等网页内容标签，在这里的标签中的内容会在浏览器中显示出来。 注释1&lt;!--注释文字 --&gt; html 的注释为 &lt;!–我是注释–!&gt; CSS的注释为 /我是注释/ JS的单行注释为 //我是注释，多行注释为 /我是注释/ 标签第一部分body 标签网页上显示的内容都放在 &lt;body&gt; 标签中。 标题标签12&lt;hx&gt;标题文本&lt;/hx&gt;如一级标题：&lt;h1&gt;标题内容&lt;/h1&gt; 除了 &lt;h1&gt; 标签外，还有 &lt;h2&gt;、&lt;h3&gt;、&lt;h4&gt;、&lt;h5&gt;、&lt;h6&gt;，数字越大字号越小，h1 字号最大，h6 最小。 段落标签1&lt;p&gt;段落内容&lt;/p&gt; 多个段落分别放在多个 &lt;p&gt; 标签中。 强调标签12&lt;em&gt;需要强调的文本&lt;/em&gt;&lt;strong&gt;需要强调的文本&lt;/strong&gt; &lt;em&gt; 标签表示强调，默认用斜体标示。&lt;strong&gt; 表示更加强调，默认用粗体表示。两者均可用 CSS 样式来修改。 span 标签&lt;span&gt; 标签是没有语义的，他的作用是设置单独的样式。123456789101112131415&lt;span&gt;文字&lt;/span&gt;下面例子将 "美国梦" 改为了蓝色&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;&lt;title&gt;了不起的盖茨比&lt;/title&gt;&lt;style&gt;span&#123; color:blue;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;1922年的春天，一个想要成名名叫尼克•卡拉威（托比•马奎尔Tobey Maguire 饰）的作家，离开了美国中西部，来到了纽约。那是一个道德感渐失，爵士乐流行，走私为王，股票飞涨的时代。为了追寻他的&lt;span&gt;美国梦&lt;/span&gt;，他搬入纽约附近一海湾居住。&lt;/p&gt; &lt;p&gt;菲茨杰拉德，二十世纪美国文学巨擘之一，兼具作家和编剧双重身份。他以诗人的敏感和戏剧家的想象为"爵士乐时代"吟唱华丽挽歌，其诗人和梦想家的气质亦为那个奢靡年代的不二注解。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 短文本引用引用别人的话使用 &lt;q&gt; 标签，引用的话默认会被加上双引号，注意这里双引号不是重点，而在于引用别人的话。1最初知道庄子，是从&lt;q&gt;庄生晓梦迷蝴蝶，望帝春心托杜鹃&lt;/q&gt;开始的。 &lt;blockquote&gt; 用来引用长文本，不同于 标签的是浏览器对 &lt;blockquote&gt; 标签解析的是左右缩进样式。 1&lt;blockquote&gt;明月出天山，苍茫云海间。长风几万里，吹度玉门关。汉下白登道，胡窥青海湾。由来征战地，不见有人还。 戍客望边色，思归多苦颜。高楼当此夜，叹息未应闲。&lt;/blockquote&gt; 分行显示文本html 中是会自动忽略空格和回车的，在需要加回车的地方加入 &lt;br /&gt; 标签。相当于 word 文档中的空格。1234567&lt;h2&gt;《咏佳》&lt;/h2&gt;&lt;p&gt;暗淡轻黄体性柔，&lt;br /&gt;情疏意远只留香。&lt;br /&gt;何须浅碧深红色，&lt;br /&gt;自是花中第一流。&lt;/p&gt; 与之前的标签不一样，&lt;br /&gt; 是一个空标签，空标签只需写一个开始标签。这样的标签有 &lt;br /&gt;、&lt;hr /&gt;、和 &lt;img /&gt; 。 添加空格空格和回车在html中是会被自动忽略的，想要输入空格，必须写 &amp;nbsp; 。1暗淡&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;轻黄体性柔，情疏迹远只留香。 注意 &amp;nbsp; 是带有 ; 的。 添加水平线使用 &lt;hr&gt; 标签，html1.0 中为 &lt;hr /&gt;，html4.01 中为 &lt;hr&gt;，现在一般使用 hxml1.0 版本的规范。1&lt;hr /&gt; &lt;hr /&gt; 和 &lt;br /&gt; 一样，也是一个空标签，所以也是有开始没有结束，当然其样式也可用 CSS 来修改。 网页加入地址信息使用 &lt;adress&gt; 标签为网页加入地址信息。如公司的地址邮件等信息。默认用斜体显示。1&lt;address&gt;深圳市南山区南光路。&lt;/address&gt; 插入代码文章中插入单行代码可以使用 &lt;code&gt; 标签。多行时可以使用 &lt;pre&gt; 标签。12345678&lt;code&gt;var i = 30; i++;&lt;/code&gt;&lt;pre&gt;var message="欢迎";for(var i=1;i&lt;=10;i++)&lt;br&gt;&#123;&lt;br&gt; alert(message); &lt;br&gt;&#125;&lt;br&gt;&lt;/pre&gt; 标签第二部分添加新闻信息列表(无序)网页中会有很多的列表，如新闻列表、图片列表等。这样的列表可以使用 ul-li 标签来完成，其代表没有前后顺序的信息列表。12345&lt;ul&gt; &lt;li&gt;少年&lt;/li&gt; &lt;li&gt;你好么&lt;/li&gt; &lt;li&gt;美丽的出现&lt;/li&gt;&lt;/ul&gt; 添加有序的信息列表有序列表使用标签 &lt;ol-li&gt; 来实现。12345&lt;ol&gt; &lt;li&gt;貂蝉&lt;/li&gt; &lt;li&gt;西施&lt;/li&gt; &lt;li&gt;昭君&lt;/li&gt;&lt;/ol&gt; div 在排版中的作用网页制作中了，通常把一些独立的逻辑划分出来，放在一个 &lt;div&gt; 标签中，这个标签就相当于一个容器。1234567891011121314151617181920212223242526&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;&lt;title&gt;div标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;h2&gt;热门课程排行榜&lt;/h2&gt; &lt;ol&gt; &lt;li&gt;前端开发面试心法 &lt;/li&gt; &lt;li&gt;零基础学习html&lt;/li&gt; &lt;li&gt;javascript全攻略&lt;/li&gt; &lt;/ol&gt; &lt;/div&gt; &lt;div&gt; &lt;h2&gt;最新课程排行&lt;/h2&gt; &lt;ol&gt; &lt;li&gt;版本管理工具介绍—Git篇 &lt;/li&gt; &lt;li&gt;Canvas绘图详解&lt;/li&gt; &lt;li&gt;QQ5.0侧滑菜单&lt;/li&gt; &lt;/ol&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 为 div 命名，使逻辑更加清晰可以用 id 属性为每个 div 命名，是逻辑更加清晰，每个名称是唯一的。1234567891011121314151617&lt;div id="名称"&gt;...&lt;/div&gt;&lt;div id="hotList"&gt; &lt;h2&gt;热门课程排行榜&lt;/h2&gt; &lt;ol&gt; &lt;li&gt;前端开发面试心法 &lt;/li&gt; &lt;li&gt;零基础学习html&lt;/li&gt; &lt;li&gt;javascript全攻略&lt;/li&gt; &lt;/ol&gt;&lt;/div&gt;&lt;div id="learningGuide"&gt; &lt;h2&gt;web前端开发导学课程&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;网页专业名词大扫盲 &lt;/li&gt; &lt;li&gt;网站职位定位指南&lt;/li&gt; &lt;li&gt;为您解密Yahoo网站制作流程&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 网页上的表格，table 标签想要创建表格的四个元素：table、tbody、tr、th、td 整个表格以 &lt;table&gt; 标记开始，&lt;/table&gt; 标记结束。 &lt;tbodu&gt;...&lt;/tbody&gt; 当表格中内容很多时，表格会边下载边显示，但是加上 &lt;tbody&gt; 标签后，就会等下载完成才显示。 &lt;tr&gt;...&lt;/tr&gt; 表格的一行，表格有多少行，就有多少对 tr。 &lt;tb&gt;...&lt;/tb&gt;，表格的一个单元格，一行包含几对 tb 说明表格就有几列。 &lt;th&gt;...&lt;/th&gt; 表格头部的单元格，表格的表头。 表格中列的个数，取决于一行中单元格的个数。123456789101112131415161718192021222324&lt;table&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th&gt;班级&lt;/th&gt; &lt;th&gt;学生数&lt;/th&gt; &lt;th&gt;平均成绩&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;一班&lt;/td&gt; &lt;td&gt;30&lt;/td&gt; &lt;td&gt;89&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;二班&lt;/td&gt; &lt;td&gt;35&lt;/td&gt; &lt;td&gt;85&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;三班&lt;/td&gt; &lt;td&gt;38&lt;/td&gt; &lt;td&gt;88&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 用 CSS 样式，为表格加入边框。下面使用了 css 样式代码为 th、td 单元格加粗细为一个像素的黑色边框。1234567891011121314151617181920212223242526272829303132333435&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;&lt;title&gt;为表格添加边框&lt;/title&gt;&lt;style type="text/css"&gt;table tr td,th&#123; border:1px solid #000;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;table summary=""&gt; &lt;tr&gt; &lt;th&gt;班级&lt;/th&gt; &lt;th&gt;学生数&lt;/th&gt; &lt;th&gt;平均成绩&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;一班&lt;/td&gt; &lt;td&gt;30&lt;/td&gt; &lt;td&gt;89&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;二班&lt;/td&gt; &lt;td&gt;35&lt;/td&gt; &lt;td&gt;85&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;三班&lt;/td&gt; &lt;td&gt;32&lt;/td&gt; &lt;td&gt;80&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 为表格添加标题和摘要摘要是不会显示出来的，只是为了增加表格的可读性（语义化），也可帮助搜索引擎更好地读懂其内容。1&lt;table summary="表格简介摘要"&gt; 标题用来描述表格内容，显示在表格上方，使用 &lt;caption&gt;...&lt;/caption&gt; 标签。12345678&lt;table&gt; &lt;caption&gt;表格标题&lt;/caption&gt; &lt;tr&gt; &lt;td&gt;...&lt;/td&gt; &lt;td&gt;...&lt;/rd&gt; ... &lt;/tr&gt;&lt;/table&gt; 标签第三部分超链接的实现使用 &lt;a&gt; 标签可以实现超链接。有链接的地方就会有这个标12&lt;a href="目标地址" title="鼠标滑过显示的文本"&gt;连接显示的文本&lt;/a&gt;&lt;a href="www.baidu.com" title="点击去度娘搜索"&gt;点我搜索&lt;/a&gt; title 的作用在网站开发中的作用很大，主要方便搜索引擎了解链接地址的内容（语义化更友好）。链接默认显示为蓝色字体，后面可以通过 CSS 样式修改。 打开的网页默认在当前的页面打开，如果需要在新的页面打开，需要使用 target 。1&lt;a href="www.baidu.com target="_blank"&gt;click me&lt;/a&gt; 网页中链接 E-mail 地址&lt;a&gt; 的另一个作用便是链接 E-mail 地址。使用 mailto 可以链接收件人地址，详细如下：1234567&lt;a herf="mailto:lihongyuan@lewanny.com;lihongyuan@163.com?cc=1016201450@qq.com&amp;bcc=1016201450@qq.com&amp;subject=邮件主题&amp;body=邮件内容"&gt;其中 mailto: 为邮件地址，浏览器将会调用默认的邮件软件填入。cc: 抄送地址。bcc: 密件抄送地址。多个收件人、抄送人可用 ； 隔开。subject= 邮件的主题。body= 邮件的内容。 网页插入图片可以使用 &lt;img&gt; 标签为网页插入图片。其中 src 用来标记图片的位置。alt 指定描述文本，当图片下载失败或不显示时显示。title 图片可见时的描述。图像可以是 GIF，PNG，JPEG 的图像文件。1&lt;img src="xx.png" alt="图片下载失败时的提示" title="图片提示文本"&gt; 与浏览者交互，表单标签使用表单标签和浏览者交互网站通过表单标签和用户进行交互 &lt;form&gt; ，表单可以把浏览者输入的数据传到服务器，这样服务器就可以处理表单然后再传数据回来。1&lt;form method="传送方式 post/get" action="服务器文件，如一个 PHP 页面 save.php"&gt; 注意：所有的控件（按钮、文本框、复选框等）等必须放在 &lt;form&gt;&lt;/form&gt; 之间，才可以上传到服务器。12345678&lt;form method="post" action="save.php"&gt; &lt;label for="username"&gt;用户名:&lt;/label&gt; &lt;input type="text" name="username" id="username" value="" /&gt; &lt;label for="pass"&gt;密码:&lt;/label&gt; &lt;input type="password" name="pass" id="pass" value="" /&gt; &lt;input type="submit" value="确定" name="submit" /&gt; &lt;input type="reset" value="重置" name="reset" /&gt;&lt;/form&gt; 文本输入框和密码输入框当用户输入时，可以使用文本输入框，当然文本输入框也可以转换为密码输入框。123&lt;form&gt;&lt;input type="text/password" name="名称" value="文本" placeholder/&gt;&lt;/form&gt; type 为 text 时为文本输入框，为 password 时为密码输入框。name 为文本框命名，以备后台 ASP 、PHP 使用。value 文本框的默认显示内容，起到提示性作用。placeholder 默认的提示性文字。 12345&lt;form&gt;姓名：&lt;input type="text" name="账号输入框" value="请输入您的用户名" /&gt;&lt;br /&gt;密码：&lt;input type="password" name="密码输入框" value="请输入您的密码" /&gt;&lt;/form&gt; 文本域支持多行输入当需要多行输入时可以使用文本域。12345&lt;textarea rows="行数" cols="列数"&gt;默认文本&lt;/textarea&gt;&lt;form method="post" action="save.php"&gt; &lt;label&gt;联系我们：&lt;/label&gt; &lt;textarea rows=33 cols=12&gt;在这里输入您的内容...&lt;/textarea&gt;&lt;/form&gt; rows 为行数，可用 CSS 样式中的 width 来代替。cols 为列数，可用 CSS 样式中的 height 来代替。 单选框和复选框网页中为减少用户的操作，可以为用户提供单选框和复选框两种。1&lt;input type="radio/checkbox" value="值" name="名称" checked="checked" /&gt; type 为 radio 时为单选框，为 checkbox 时为复选框。value 提交到服务器的值，供后台 PHP 程序使用。name 为空间名，供后台 ASP、PHP 程序使用。checked 被设置为 checked=”checked” 时，该项默认被选中。 1234567891011121314151617181920212223242526272829&lt;form name=""iForm method="post" action="save.php"&gt; 你是否喜欢编程？&lt;br /&gt; &lt;input type="radio" name="codeLove" value="喜欢" checked="checked" /&gt; 喜欢 &lt;input type="radio" name="codeLove" value="非常喜欢" /&gt;非常喜欢 &lt;input type="radio" name="codeLove" value="有点喜欢" /&gt; &lt;br /&gt;有点喜欢 你喜欢的运动？&lt;br /&gt; &lt;input type="checkbox" name="sportLove" value="羽毛球" /&gt;羽毛球 &lt;input type="checkbox" name="sportLove" value="篮球" /&gt;篮球 &lt;input type="checkbox" name="sportLove" value="游泳" /&gt; 游泳 &lt;input type="checkbox" name="sportLove" value="跑步" /&gt;跑步&lt;/form&gt;``` 注意：同一组的单选按钮，name 值一定要保持一致，如上面的 name 值都为 codeLove 。#### 下拉列表来节省空间```html&lt;form name="iForm"&gt; &lt;lable&gt;你的爱好&lt;/lable&gt; &lt;select&gt; &lt;option value="运动"&gt;羽毛球&lt;/option&gt; &lt;option value="音乐"&gt;音乐&lt;/option&gt; &lt;option value="旅游"&gt;旅游&lt;/option&gt; &lt;option value="读书" selected="selected"&gt;读书&lt;/option&gt; &lt;option value="游戏"&gt;游戏&lt;/option&gt; &lt;/select&gt;&lt;/form&gt; value 为提交的值，标签之间为显示的值。selected 值为 selected 时，该项默认为选中项。 下拉列表多选下拉列表也可进行多选操作。在 select 标签中设置 multiple=&quot;multiple&quot; 即可实现。按键盘 control/command 键即可多选。12345678910&lt;form name="iForm2"&gt; &lt;label&gt;你的爱好&lt;/label&gt; &lt;select multiple="multiple"&gt; &lt;option value="运动"&gt;运动&lt;/option&gt; &lt;option value="音乐"&gt;音乐&lt;/option&gt; &lt;option value="旅游"&gt;旅游&lt;/option&gt; &lt;option value="读书"&gt;读书&lt;/option&gt; &lt;option value="旅游"&gt;游戏&lt;/option&gt; &lt;/select&gt;&lt;/form&gt; 使用提交按钮来提交数据表单中有两种按钮，一个是提交，一个是重置。1&lt;input type="submit/reset" value="提交"/&gt; type 只有当 type 值设置为 submit 时，按钮才有提交作用，type 值为 reset 时为重置作用。value 按钮上显示的文字。 123456&lt;form method="post" action="save.php"&gt; &lt;label&gt;姓名：&lt;/label&gt; &lt;input type="text" name="myName" value=" "/&gt; &lt;input type="submit" value="提交" name="submit" /&gt; &lt;input type="reset" value="重置" name="reset" /&gt;&lt;/form&gt; form 表单中的 label 标签label 不会呈现任何特殊效果，它为鼠标用户改进了可用性。如果你在 label 内点击文本，就会触发该控件。就是说，当用户单击选中该 label 标签时，浏览器就会自动将焦点转到和标签相关的表单控件上（就自动选中和该label标签相关连的表单控件上）。1&lt;label for="控件的 id 名称"&gt; 注意：label 的 for 属性的值应与相关控件 id 属性值相同。12345678&lt;form&gt; &lt;label for="male"&gt;男性&lt;/label&gt; &lt;input type="radio" name="gender" id="male" /&gt; &lt;label for="female"&gt;女性&lt;/label&gt; &lt;input type="radio" name="gender" id="female" /&gt; &lt;label for="email"&gt;输入您的邮箱地址&lt;/label&gt; &lt;input type="text" id="email" placeholder="Enter email" /&gt;&lt;/form&gt; 未完待续…]]></content>
      <categories>
        <category>HTML+CSS</category>
      </categories>
      <tags>
        <tag>HTML+CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016 年终总结]]></title>
    <url>%2F2017%2F01%2F21%2F2017%2Fsummary-year-end-2016%2F</url>
    <content type="text"><![CDATA[2016 年的收获自 2016 年 3 月中加入深圳市蜗爱生活科技开发有限公司。2016 全年的工作过程中，有很多收获也有很多的不足之处。其中的收获、不足之处、和 2017 年的计划总结如下： 通过对公司现有蓝牙库的维护和对新蓝牙库的初步开发工作。对蓝牙库的架构有了一定的认识，也更加深入的了解了 iOS 了的蓝牙开发技术以及蓝牙数据通信的原理。 关于新技术的学习，和 iOS 组的成员一起学习了 Swift ，在技术调研工作中也学习到了很多之前未接触到技术，如私有库的制作使用等。同时搭建了个人的技术博客，把工作和调研中遇到的问题都记录下来。 2017 年的目标项目1、更加深入的了解公司产品的理念和设计，项目过程中以用户的角度来实现功能，要具体的参与到每一个产品当中。2、更多的实现共性代码的抽离，模块化实现功能也界面，做到每个项目的具体模块化。3、命名结构等要更加规范、代码结构要更加强壮。4、提升代码的可拓展性和可移植性。 可量化目标如下时间：2017 年 1 月 16 日 - 2017 年 12 月 31 日部门统一计划1、Blog 新增 10 篇高质量博客。完成度：Blog-Lewanny + 3 篇[30%]。2、GitHub 开源 2 个项目，每个项目收获 50 个 Star。3、StackOverflow 新增 50 reputation： 1 -&gt; 51。4、SegmentFault 新增 50 声望： 81 -&gt; 131。完成度：Segmentfault-Lewanny + 17 声望 [34%]。5、知乎新增 50 个赞： 0 -&gt; 50。 个人计划1、经常在个人博客中总结遇到的问题或技术点，每月至少一篇总结性文章2、一本好书就像良师益友，读三本书：非技术的《左手天才，右手疯子》，技术类的 《 React：用 JavaScript 开发移动应用》和《 ReactNative：引领未来的用户界面开发框架》。完成度：《 React：用 JavaScript 开发移动应用》0-&gt;33 页。 [13%]3、学习前端技术（HTML+CSS），目标是建一个站。完成度：Blog-Lewanny 学习了 HTML 的基本标签和 css 样式布局。 [15%]。4、继续推进 Swift 的学习，用 Swift 写出自己的一个开源的播放器项目。 总结如上，每月更新完成进度。]]></content>
      <categories>
        <category>日常总结</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mac OS 使用技巧和一些问题的解决方法]]></title>
    <url>%2F2017%2F01%2F18%2F2017%2FMac-use-tips-and-problem-solution%2F</url>
    <content type="text"><![CDATA[升级到 mac OS Serria 10.12 后安装软件提示“已损坏， 打不开。您应该将它移到废纸篓”这是因为系统安全性，禁止了安装第三方来源的应用。如果10.12 以前的系统版本，打开 设置 -&gt; 安全与隐私 -&gt; 通用，然后把选项允许从以下位置下载的应用选择为“任何来源”即可。 10.12系统以后会发现该选项下只有 “App Store” 和“App Store 和被认可的开发者“。需要 Terminal 中执行以下命令： sudo spctl --master-disable 然后就会出现 ”任何来源“ 选项，选择即可。 mac 清倒废纸篓时出现，提示“操作无法完成因为项目xx正在使用/被锁定”解决方法一：到废纸篓中找到该文件，回车将其重命名，再操作删除即可。 解决方法二：打开 Terminal [终端]，执行以下命令12cd ~/.Trash // 进入到废纸篓的目录chflags -R nouchg * // 更改系统权限 解决方法三：如果以上方法都不行，可以尝试使用强制删除，在终端中分别执行下面的命令：123cd ~/.Trash // 进入到废纸篓的目录ls // 查看目录下无法被删除的文件rm xx.xxx // 使用 rm 命令删除上面的文件，xx.xxx 为 ls 后显示的文件名。 推荐方法一和方法二。]]></content>
      <categories>
        <category>mac OS</category>
      </categories>
      <tags>
        <tag>mac OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 使用 RVM 升级 Ruby 解决 CocoaPods 无法生成 xcworkspace 文件的问题]]></title>
    <url>%2F2017%2F01%2F04%2F2017%2Fupdate-Ruby-by-RVM-CocoaPods-xcworkspace-solution%2F</url>
    <content type="text"><![CDATA[在安装 CococaPods 时，出现执行 pod install 后成功后却没有生成对应的 xcworkspace 文件问题，查找后发现是本地 Ruby 环境版本过低，需要升级至 2.2.2 以上。在终端中输入 ruby -v 查看 Ruby 版本，果然版本为 2.0.0 。 升级 Ruby 环境可以使用 RVM ，也就是 Ruby Version Manager , Ruby 版本管理器。RVM 包含了 Ruby 的版本管理和 Gem 库管理 (gemset)。RVM 可以让你拥有多个版本的 Ruby，并且可以在多个版本之间自由切换。 下面的命令全部在终端中进行。 RVM 安装1curl -L get.rvm.io | bash -s stable 等待一段时间后就可以成功安装好 RVM 。 测试是否安装正常1rvm -v 出现版本号即安装成功。 列出已知的 Ruby 版本1rvm list known 安装指定版本的 Ruby1rvm install 2.3.3 RVM 可以让你拥有多个版本的 Ruby，如果安装不成功，可以试着安装其他的版本，高于 2.2.2 即可。 查看当前 Ruby 版本和列表使用 ruby -v 查看当前的 Ruby 版本 。使用 rvm list 查看当前所有的 Ruby 版本列表 。 设置默认的 Ruby 版本1rvm default 2.3.3 到此，Ruby 环境变更新完，重新到你的工程目录下执行 pod install 便可正确安装 CococaPods 。 更新可能遇到的问题更新过程中报错如下：123Error running 'Requirements_oxs_brew_update_system ruby -2.3.3',showing last 15 lines of /User/Lihongyuan/.rvm/log/848784602_ruby-2.3.3/update system.logRequirements installation failed with status: 1. 解决方法：卸载 home-brew 。1ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)" 然后再次安装即可。1rvm install 2.3.3]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>CocoaPods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 私有 API、未公开 API 和公开 API 的对比和使用]]></title>
    <url>%2F2016%2F12%2F22%2F2016%2FiOS-private-API-acquire-and-usage%2F</url>
    <content type="text"><![CDATA[iOS 的 API 除了公开的 API 以外，还有两类，分别是私有 API 和未公开 API 。iPhone 编程中一些非常精致强大的 API 都包含在私有 API 或未公开的 API 中，但未公开的 API 非常不稳定，变更的可能性很大。同时，最大的问题是使用了私有 API 的程序是不能上架 App Store 的。下面是三种 API 的介绍和对比。 公开API（Published API）介绍Published API（公开的 API）：又称 Documented API（文档中记录的 API）。也就是是苹果通过 Cocoa Touch 向全世界第三方开发者公开的所有 API 。 使用所有的公有 API 的介绍和使用方法都有记录在 Apple 的官方文档中。 未公开API（UnPublished API）介绍UnPublished API（未公开 API）：又称 Undocumented API（文档中未记录的 API ）。是指虽然放在 Frameworks 框架中，但是却没有在苹果的官方文档中有使用说明、代码介绍等记录的 API 。按苹果的说法，未公开的 API 是还不够成熟，可能还会变动的 API ，等完全成型了后会变成公开的 API ，但是目前不对其提供承诺，就是系统版本升级后可能会失效。 使用是目前不对其提供未公开 API 虽然未公开，但已经放在了公开的 Frameworks 框架中，所以他的使用方法和公开 API 一样，只要知道了对应的方法名，直接调用即可。 补充如果应用中使用了未公开的 API ，程序是不能在苹果的 App Store 上发布的。当然也可以通过某些加密的方法躲过审核。 私有API（Private API）介绍：Private API（私有API）：指的是 SDK 下的 PrivateFrameWorks 框架下的 API ，真实存在于 Cocoa Touch 中，私有 API 是苹果明确规定不能使用的 API 。 一旦你的程序中有私有 API，在上传 AppStore 的时候也是会被拒绝的。如果当作小范围软件的话就可以尝试一下，比如再 Cydia 上发布，91 上发布，条件不会很苛刻。 私有 Frameworks 的位置私有的 Frameworks 存放在 Xcode 包的目录下，这里以 ChatKit 举例： Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS9.2.sdk/System/Library/PrivateFrameworks/ChatKit.framework 如何获取私有 API使用 class-dump 获取对应 Frameworks 的头文件。 下载class-dump可以在 class-dump 官网 直接下载，或者下载 class-dump 源代码 编译得到。 class-dump 放到本地目录把 class-dump 放到本地的 /usr/local/bin 目录下（有的系统是 “/usr/bin” ），在终端输入 class-dump ，显示 class-dump 后就可以正常使用了。如下图： 修改 class-dump 权限进入到 class-dump 所在目录，执行如下命令，修改 class-dump 的权限为可读可写。1chmod 777 class-dump 执行 class-dump -H 命令执行如下命令便可导出对应私有 Frameworks 的头文件，我以 ChatKit.framework 为例。1class-dump -H /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneOS9.2.sdk/System/Library/PrivateFrameworks/ChatKit.framework -o/Users/apple/Desktop/Headers 解释class-dump -H class-dump 导出头文件命令。/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneOS9.2.sdk/System/Library/PrivateFrameworks/ChatKit.framework 需要 dump 文件的路径。-o/Users/apple/Desktop/Headers dump 出来头文件的文件夹路径。 导出的头文件： 如何使用私有 API现在我们有了对应的 Frameworks 文件和头文件，然后新建一个名为 Headers 的文件夹 将 dump 出来的头文件放到 Headers 文件夹中，在把 Headers 放到 Framework 文件中。然后在工程中导入 Frameworks ，就可以以静态库的方式在我们的代码中使用这些私有 API 函数了。 补充现在 iOS 9.3 以后，苹果取消了所有私有 API 的开放，所以现在不能拿到私有的 API 了，只能拿到虚拟机的私有 API，方法同上。目录如下： /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator9.2.sdk/System/Library/PrivateFrameworks/xx.framework]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>私有 Api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 学习 - 基本运算符]]></title>
    <url>%2F2016%2F12%2F04%2F2016%2FSwift-learn-part2-operator%2F</url>
    <content type="text"><![CDATA[Swift 支持大部分标准 C 语言的运算符，且改进许多特性来减少常规编码错误。Swift 还提供了 C 语言没有的表达两数之间的值的区间运算符（a..&lt;b 和 a…b），这方便我们表达一个区间内的数值。 术语运算符分为一元、二元和三元运算符: 一元运算符对单一操作对象操作，如 -1 ，一元运算符分前置运算符和后置运算符，如 !b 和 c! 二元运算符操作两个操作对象，是中置的，如 2 + 3 三元运算符操作三个操作对象，和 C 语言一样，Swift 只有一个三元运算符，即三目运算符 a ? b : c 受运算符影响的值叫操作数，如在 1 + 2 中，加号 + 是二元运算符，它的两个操作数是值 1 和 2。 赋值运算符用来初始化或更新一个变量或者常量的值：123let a = 10var b = 5b = a 如果元祖类型被赋值，那么它的元素可以马上被分解成多个常量或变量12let(x, y) = (2, 3)// x = 2, y = 3 与 C 语言和 Objective-C 不同，Swift 的赋值操作并不返回任何值。123if x = y &#123; // 错误, 因为 x = y 并不返回任何值&#125; 算术运算符Swift 中所有数值类型都支持了基本的四则算术运算符：加法（+） 减法（-） 乘法（*） 除法（/）与 C 语言和 Objective-C 不同的是，Swift 默认情况下不允许在数值运算中出现溢出情况。加法（+） 运算符也可用于 String 的拼接：1var heStr = "hello" + "world" 求余运算符（a % b）运来计算 a 是 b 倍数的余数，在其他语言也叫取模运算符1239 % 4 = 1 // 9 = (2 * 4) + 1 余数为 1-9 % 4 = -1 // -(9 % 4) = -19 % -4 = 1 // - 号会被省略 一元正号运算符和一元负号运算符数值的正负号可以使用前缀 -（即一元负号符）来切换。123let three = 3let minThree = -three // minThree 为-3let plusThree = -minThree // plusThree 为 3 或者 负3 一元正号符（+）不做任何改变地返回操作数的值，他的作用是当你在使用一元负号来表达负数时，你可以使用一元正号来表达正数，使你的代码更美观。 组合赋值运算符如同 C 语言，Swift 也提供把其他运算符和赋值运算（=）组合的组合赋值运算符，例如组合加运算（+=）12var a = 2a += 1 // 即a = a + 1 , a = 3 复合赋值运算没有返回值，let b = a += 2 这类代码是错误。这点不同于自增和自减运算符。 比较运算符等于（a == b）不等于（a != b）大于（a &gt; b）小于（a &lt; b）大于等于（a &gt;= b）小于等于（a &lt;= b）恒等（===）和不恒等（!==）比较符来判断两个对象是否引用同一个对象实例。 每个比较运算都返回了一个标识表达式是否成立的布尔值，多用于条件语句，如if条件：1234let name = "world"if name == world &#123;&#125; else &#123;&#125; 元组中的值也可以比较，但 Bool 值不能比较，所有包含。 持续更新中…]]></content>
      <categories>
        <category>Swift 学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 通话或网络共享等状态栏变化导致 view 偏移的解决方法]]></title>
    <url>%2F2016%2F11%2F30%2F2016%2FiOS-solution-view-offset-when-calling%2F</url>
    <content type="text"><![CDATA[当使用 iPhone 打电话、共享网络或者录音时，会发现状态栏下移了 20 个像素，这时对应的 Controller 的 frame 高度也就减少了 20 个像素，如果程序的约束和对应的适配不到位，便会导致某些控价被遮挡显示不全。 所以我们需要根据 view 的 frame 去布局子 view 。 原因经测试，在iPhone6上状态栏下移的时候，self.view.frame 的高度由原来的 667 变成了 647 ， 减少了 20 的高度，还原后仍变回 667 ，这样如果控件的 frame 没有做对应的边距约束，便会发生这样的问题。 解决方案做好控件的约束在项目一开始时就要考虑到相应的问题，如在对一个距底部为 10 的 view 布局时，应避免根据屏幕尺寸的绝对布局，应使用 view 距底部 10 这样的约束布局，这样即使状态栏下移，控件距底部仍未 10 不会被遮挡。 监听状态栏变化的通知经过步骤 1 的处理，若仍有些控件的位置发生位移或重叠，这时我们就可以监听状态栏变化的通知，对view进行重布局。12// 在init的时候监听状态栏改变的通知 UIApplicationDidChangeStatusBarFrameNotification[[ NSNotificationCenter defaultCenter ] addObserver : self selector : @selector (layoutControllerSubViews) name : UIApplicationDidChangeStatusBarFrameNotification object : nil ]; 通过以上方法，便可在通话等状态栏变化的时候对我们应用的控件布局进行相应的调整。]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[应用 Crash 捕获库 NullSafe 和 AvoidCrash 对比]]></title>
    <url>%2F2016%2F11%2F28%2F2016%2FiOS-comparison-of-NullSafe-and-AvoidCrash%2F</url>
    <content type="text"><![CDATA[在前 “iOS null 导致程序 Crash 的解决方案” 文章中提到使用 NullSafe 框架在运行时操作，把空值置为 nil ，从而防止操作 nil 值引起程序 Crash 。针对防止程序 Crash 的框架还有 AvoidCrash ，下面对两个框架进行了对比。 NullsafeAvoidCrash 不同的作用NullSafeNullSafe 可在运行时，把虽有的空值置为 nil ，可有效的防止所有的空值问题引起的Crash 。 AvoidCrashAvoidCrash 利用 runtime 技术对 Foundation 一些常用并且容易导致崩溃的方法进行处理。 目前可以防止崩溃的方法有:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455561. NSArrayNSArray的快速创建方式 NSArray *array = @[@”chenfanfang”, @”AvoidCrash”];+ (instancetype)arrayWithObjects:(const id _Nonnull __unsafe_unretained *)objects count:(NSUInteger)cnt- (id)objectAtIndex:(NSUInteger)index2. NSMutableArray- (id)objectAtIndex:(NSUInteger)index- (void)setObject:(id)obj atIndexedSubscript:(NSUInteger)idx- (void)removeObjectAtIndex:(NSUInteger)index- (void)insertObject:(id)anObject atIndex:(NSUInteger)index3. NSDictionaryNSDictionary 的快速创建方式 NSDictionary *dict = @&#123;@”frameWork” : @”AvoidCrash”&#125;; // 这种创建方式其实调用的是2中的方法。- (instancetype)dictionaryWithObjects:(const id _Nonnull unsafe_unretained *)objects forKeys:(const id _Nonnull unsafe_unretained *)keys count:(NSUInteger)cnt4. NSMutableDictionary- (void)setObject:(id)anObject forKey:(id)aKey- (void)removeObjectForKey:(id)aKey5. NSString- (unichar)characterAtIndex:(NSUInteger)index- (NSString *)substringFromIndex:(NSUInteger)from- (NSString *)substringToIndex:(NSUInteger)to &#123;- (NSString *)substringWithRange:(NSRange)range &#123;- (NSString )stringByReplacingOccurrencesOfString:(NSString )target withString:(NSString *)replacement- (NSString )stringByReplacingOccurrencesOfString:(NSString )target withString:(NSString *)replacement options:(NSStringCompareOptions)options range:(NSRange)searchRange- (NSString )stringByReplacingCharactersInRange:(NSRange)range withString:(NSString )replacement6. NSMutableString由于 NSMutableString 是继承于 NSString，所以这里和 NSString 有些同样的方法就不重复写了。- (void)replaceCharactersInRange:(NSRange)range withString:(NSString *)aString- (void)insertString:(NSString *)aString atIndex:(NSUInteger)loc- (void)deleteCharactersInRange:(NSRange)range7. KVC- (void)setValue:(id)value forKey:(NSString *)key- (void)setValue:(id)value forKeyPath:(NSString *)keyPath- (void)setValue:(id)value forUndefinedKey:(NSString *)key //这个方法一般用来重写，不会主动调用- (void)setValuesForKeysWithDictionary:(NSDictionary *)keyedValues8. NSAttributedString- (instancetype)initWithString:(NSString *)str- (instancetype)initWithAttributedString:(NSAttributedString *)attrStr- (instancetype)initWithString:(NSString )str attributes:(NSDictionary&lt;NSString ,id&gt; *)attrs9. NSMutableAttributedString- (instancetype)initWithString:(NSString *)str- (instancetype)initWithString:(NSString )str attributes:(NSDictionary&lt;NSString ,id&gt; *)attrs AvoidCrash 可防止的 Crash 目前仅限以上 9 个类， 目前仍在更新中。 实现原理的异同NullSafeNSNull 发送给它的而它又无法处理的消息经过如下几步处理: 创建一个方法缓存，这个缓存会缓存项目中类的所有类名。 遍历缓存，寻找是否已经有可以执行此方法的类。 如果有的话，返回这个 NSMethodSignature 。 如果没有的话，返回 nil ， 接下来会走 forwardInvocation: 方法。 [invocation invokeWithTarget:nil] ; 将消息转发给 nil 。 在 OC 中，系统如果对某个实例发送消息之后，它（及其父类）无法处理（比如，没有这个方法等），系统就会发送 methodSignatureForSelector 消息，如果这个方法返回非空，那么就去执行返回的方法，如果为 nil，则发送 forwardInvocation 消息，这样就完成整个转发链了。 AvoidCrashAvoidCrash 利用 runtime 技术对一些常用并且容易导致崩溃的方法进行处理，可以有效的防止崩溃。 通过 category 给类添加方法用来替换掉原本存在潜在崩溃的方法。 利用 runtime 方法交换技术，将系统方法替换成我们给类添加的新方法。 利用异常的捕获来防止程序的崩溃，并且进行相应的处理。 两者的优势对比优势NullSafe 可自动将所有的 NSNull 对象转为 nil，直接防止空值导致的 Crash 。 作为 Extension 使用方便，一劳永逸。 AvoidCrash 可捕获常用的 Foundation 中的方法存在潜在崩溃风险。 可定位到具体的 Crash 位置。 可以获取崩溃日志的所有详细信息。 可拓展性强。 ####劣势 NullSafe 仅仅局限于处理空对象，而 AvoidCrash 可捕获用的 Foundation 方法的 Crash 。 可拓展性差。 AvoidCrash 仅作用于常用的 Foundation 中的方法的 Crash 。 目前版本并不是很稳定。 两者的使用方法NullSafeNullSafe 是一个 Category，使用起来非常方便，只要加入到了工程中就可以了。 AvoidCrash 在 AppDelegate 的 didFinishLaunchingWithOptions 方法中添加如下代码，让 AvoidCrash 生效。 12// 这句代码会让AvoidCrash生效，若没有如下代码，则AvoidCrash就不起作用[AvoidCrash becomeEffective]; 如果想要获取崩溃日志的所有详细信息，需要注册通知：AvoidCrashNotification 。 12345678910111213- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; [AvoidCrash becomeEffective]; //监听通知:AvoidCrashNotification, 获取AvoidCrash捕获的崩溃日志的详细信息 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(dealwithCrashMessage:) name:AvoidCrashNotification object:nil]; return YES;&#125;- (void)dealwithCrashMessage:(NSNotification *)note &#123; //注意:所有的信息都在userInfo中 //你可以在这里收集相应的崩溃信息进行相应的处理(比如传到自己服务器) NSLog(@"%@",note.userInfo);&#125; 总结建议综上，个人更倾向于 AvoidCrash ，虽然目前还不是很完善，但也可捕获常用的 Foundation 中的方法存在潜在崩溃风险，相对来说， NullSafe 便有些局限。 在发布 APP 的时候再用上面介绍的方法来防止程序的崩溃，在开发阶段最好不用，能更好的发现应用的问题和不足。]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>NullSafe</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS null 导致程序 Crash 的解决方案]]></title>
    <url>%2F2016%2F11%2F25%2F2016%2FiOS-null-safe-solution%2F</url>
    <content type="text"><![CDATA[现象iOS 开发中经常需要与服务器进行数据交互，JSON 是常用的高效简洁的数据格式。然而当服务器返回的数据中有些字段为空：&quot;somevalue&quot;: null 这样的数据解析成对象之后，如果直接向这个对象发送消息就会直接造成程序 Crash。 错误类型向一个空对象发送消息后造成 Crash 的错误日志为:1-[NSNull length]: unrecognized selector sent to instance 0x388a4a70 解决方案对可能出现空的字段进行非空判断会造成 Crash 的字段解析成的对象是 NSNull 类型的，所以可以直接判断是不是此类型，这样的字段会比较多所以也会比较繁琐，也容易遗漏，但是也比较保险。1if (![isKindOfClass:[NSNull class]])&#123;.....&#125; 字符串匹配, 替换 null 为 为空字符 “”在获取到服务器返回的 JSON 时，返回结果时 string 对象，于是就先替换 null 为 为空字符””，然后再解析可避免 Crash 问题，这种方法比较巧妙，但若服务器的数据不太整洁也会有一定的问题。1json = [jsonStr stringByReplacingOccurrencesOfString:@":null" withString:@":\"\""]; 解析数据时把 NSNull 类型的值替换成 nil使用宏定义。12345678#define VerifyValue(value)\(&#123;id tmp;\if ([value isKindOfClass:[NSNull class]])\tmp = nil;\else\tmp = value;\tmp;\&#125;)\ 在解析数据时，把接收到的 NSNull 类型的值替换成 nil 。1contact.contactPhone = VerifyValue(contactDic[@"send_ContactPhone"]); 使用 AFNetworking 提供的方法如果是使用 AFNetworking 这个库做网络请求的话，可以用以下代码，自动帮你去掉空值1self.removesKeysWithNullValues = YES; 第三方库 NullSafeNullsafe 是一个 Category ，在运行时操作，把这个讨厌的空值置为 nil ，而 nil 是安全的，可以向 nil 对象发送任何 message 而不会 Crash ，这个 category 使用起来非常方便，只要加入到了工程中就可以了。 附： NullSafe 的工作原理当我们给一个 NSNull 对象发送消息的话，可能会崩溃（ null 是有内存的），而发送给 nil 的话，是不会崩溃的。把发送给 NSNull 的而 NSNull 又无法处理的消息经过如下几步处理: 创建一个方法缓存，这个缓存会缓存项目中类的所有类名。 遍历缓存，寻找是否已经有可以执行此方法的类。 如果有的话，返回这个 NSMethodSignature 。 如果没有的话，返回 nil , 接下来会走 forwardInvocation:方法。 [invocation invokeWithTarget:nil]; 将消息转发给 nil。 在 OC 中，系统如果对某个实例发送消息之后，它（及其父类）无法处理（比如，没有这个方法等），系统就会发送 methodSignatureForSelector 消息，如果这个方法返回非空，那么就去执行返回的方法，如果为 nil, 则发送 forwardInvocation 消息。这样就完成整个转发链了。]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>NullSafe</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 学习 – 基础部分]]></title>
    <url>%2F2016%2F11%2F21%2F2016%2FSwift-learn-part1-basis%2F</url>
    <content type="text"><![CDATA[Swift 是一门新的编程语言，用于编写 iOS 和 OS X 应用程序。Swift 结合了 C 和 Objective-C 的优点并且不受 C 兼容性的限制。Swift 使用安全的编程模式并添加了很多新特性，这将使编程更简单，扩展性更强，也更有趣。Swift 支持 Cocoa 和 Cocoa Touch 框架。以下是 Swift 部分学习笔记整理。 常量和变量常量的值一旦设定就不能改变，而变量的值可以随意更改。常量和变量必须在使用前声明，用let来声明常量，用var来声明变量。123let maxNum = 10 // 声明一个常量var currentNum = 0 //声明一个变量var x = 0.0, y = 0.0, z = 0.0 // 可以在一行中声明多个常量或者多个变量 类型标注如果要添加类型标注，需要在常量或者变量名后面加上一个冒号和空格，然后加上类型名称。123var messageHellow: String // 声明一个类型为 String ，名字为 welcomeMessage 的变量messageHellow = "Hello world"var red, grenn, blue: Double 一般来讲类型标注可以省略，Swift可以推断出这个常量或者变量的类型 常量和变量的命名你可以用任何你喜欢的字符作为常量和变量名，包括 Unicode 字符，常量与变量名不能包含数学符号，箭头,保留的Unicode 码位。也不能以数字开头，但是可以在常量与变量名的其他地方包含数字。1234let π = 3.1415926let 你好 = "你好啊"let 🐶 = "Dog"var 'let' = "保留关键字命名" 如需要使用与Swift保留关键字相同的名称作为常量或者变量名，你可以使用反引号（`）将关键字包围的方式将其作为名字使用，如上所示。 输出常量和变量使用 print(_:separator:terminator:) 函数来输出当前常量或变量的值。12print(π)// 3.1415926 Swift 用字符串插值（string interpolation）的方式把常量名或者变量名当做占位符加入到长字符串中 \()：12print("π的值大约是\(π)"...)// 输出 "π的值大约是3.1415926... 注释和OC一样，Swift支持单行注释，多行注释 和行注释可以嵌套在其它的多行注释之中。 关于分号Swift 并不强制要求你在每条语句的结尾处使用分号，也可以按照自己的习惯添加分号。12let 🐟 = "Fish", print(🐟)// 输出 Fish 有一种情况下必须要用分号，即你打算在同一行内写多条独立的语句。 整数和整数范围整数就是没有小数部分的数字，比如 42 和 -23 。整数可以是有符号（正、负、零）或者 无符号（正、零）。 Swift 提供了8，16，32和64位的有符号和无符号整数类型，8位无符号整数类型是UInt8，32位有符号整数类型是 Int32 。就像 Swift 的其他类型一样，整数类型采用 大写命名法 你可以访问不同整数类型的 min 和 max 属性来获取对应类型的最小值和最大值：12let minValue = Unit8.min // minValue 为 0，是 UInt8 类型let maxvalue = Unit8.max // maxValue 为 255，是 UInt8 类型 IntSwift 提供了一个特殊的整数类型Int，一般来说，你不需要专门指定整数的长度。 在32位平台上，Int 和 Int32 长度相同。 在64位平台上，Int 和 Int64 长度相同。 UIntSwift 也提供了一个特殊的无符号类型 UInt，长度与当前平台的原生字长相同。 在32位平台上，UInt 和 UInt32 长度相同。 在64位平台上，UInt 和 UInt64 长度相同。 尽量不要使用UInt，除非你真的需要存储一个和当前平台原生字长相同的无符号整数。 浮点型浮点数是有小数部分的数字，比如 3.14159 ，0.1 和 -273.15。Swift 提供了两种有符号浮点数类型。 Double 表示64位浮点数。当你需要存储很大或者很高精度的浮点数时请使用此类型。 Float 表示32位浮点数。精度要求不高的话可以使用此类型。 类型安全和类型推断Swift 是一个 类型安全 （type safe）的语言，它会在编译你的代码时进行类型检查（type checks），并把不匹配的类型标记为错误。这可以让你在开发的时候尽早发现并修复错误。 因为有类型推断，和 C 或者 Objective-C 比起来 Swift 很少需要声明类型。12let meaningOfLife = 42// meaningOfLife 会被推测为 Int 类型 当推断浮点数的类型时，Swift 总是会选择 Double 而不是Float。12let anotherPi = 3 + 0.14159// anotherPi 会被推测为 Double 类型 数值型字面量下面的所有整数字面量的十进制值都是17，整数字面量可以被写作二、八、十、十六进制。1234let decimalInteger = 17 // 一个十进制数，没有前缀let binaryInteger = 0b10001 // 一个二进制数，前缀是 0blet octalInteger = 0o21 // 一个八进制数，前缀是 0olet hexadecimalInteger = 0x11 // 一个十六进制数，前缀是 0x 浮点字面量可以是十进制（没有前缀）或者是十六进制（前缀是 0x ）。十进制浮点数也可以有一个可选的指数（exponent)，通过大写或者小写的 e 来指定；十六进制浮点数必须有一个指数，通过大写或者小写的 p 来指定。 如果一个十进制数的指数为 exp，那这个数相当于基数和10^exp的乘积。121.25e2 表示 1.25 × 10^2，等于 125.0。1.25e-2 表示 1.25 × 10^-2，等于 0.0125。 如果一个十六进制数的指数为exp，那这个数相当于基数和2^exp的乘积。120xFp2 表示 15 × 2^2，等于 60.0。0xFp-2 表示 15 × 2^-2，等于 3.75。 下面的这些浮点字面量都等于十进制的 12.1875 。123let decimalDouble = 12.1875let exponentDouble = 1.21875e1let hexadecimalDouble = 0xC.3p0 为增强可读性，整数和浮点数都可以添加额外的零并且包含下划线，并不会影响字面量。123let paddedDouble = 000123.456let oneMillion = 1_000_000let justOverOneMillion = 1_000_000.000_000_1 数值型类型转换通常来讲，即使代码中的整数常量和变量已知非负，也请使用 Int 类型。 整数转换不同整数类型的变量和常量可以存储不同范围的数字。 Int8 类型的常量或者变量可以存储的数字范围是 -128~127 ，而 UInt8 类型的常量或者变量能存储的数字范围是 0~255 ，如果数字超出了常量或者变量可存储的范围，编译的时候会报错。1234let cannotBeNegative: UInt8 = -1// UInt8 类型不能存储负数，所以会报错let tooBig: Int8 = Int8.max + 1// Int8 类型不能存储超过最大值的数，所以会报错 要将一种数字类型转换成另一种，你要用当前值来初始化一个想要类型的新数字，如下面调用 UInt16(one) 来创建一个新的UInt16数字并用one的值来初始化，将one转换成UInt16类型来完成运算。123let twoThousand: Unit16 = 2_000let one: Unit8 = 1let twoThousandAndOne = twoThousand + Unit16(one) SomeType(ofInitialValue) 是调用 Swift 构造器并传入一个初始值的默认方法。注意，你并不能传入任意类型的值，只能传入 UInt16 内部有对应构造器的值。不过你可以扩展现有的类型来让它可以接收其他类型的值。 整数和浮点数转换整数和浮点数的转换必须显式指定类型1234let three = 3let pointValue = 2.14159let sumValue = three + Int(pointValue)// 结果 5 当用这种方式来初始化一个新的整数值时，浮点值会被截断。也就是说 4.75 会变成 4，-3.9 会变成 -3。 类型别名类型别名（type aliases）就是给现有类型定义另一个名字，使用 typealias 关键字来定义类型别名，类似于OC中的宏定义。123typealias AudioSample = Unit16var max = AudioSample.min// max = 0 布尔值Swift 有一个基本的布尔类型 Bool，布尔值指逻辑上的值，因为它们只能是真或者假。Swift 有两个布尔常量，true 和 false 。123456let isSuccess = trueif isSuccess &#123; print("Success")&#125; else &#123; print("Failed")&#125; 如果你在需要使用 Bool 类型的地方使用了非布尔值，Swift 的类型安全机制会报错。1234let i = 1if i == 1 &#123; // 这个例子会编译成功&#125; 元组类型一种全新的数据类型，元组（tuples）把多个值组合成一个复合值。元组内的值可以是任意类型，并不要求是相同类型。12let http404Err = (404, "not found")// http404Error 的类型是 (Int, String)，值是 (404, "Not Found") 你可以将一个元组的内容分解（decompose）成单独的常量和变量来使用，分解的时候可以把要忽略的部分用下划线 _ 标记。123let(code, message) = http404Errprint("code = \(code), message = \(message))// 输出 code = 404, message = not found 可以在定义元组的时候给单个元素命名。1let http200Status = (code: 200, description: "OK") 使用时可以使用名字或者下标老获取对应的值。1234print("code = http200Status.0, description = http200Status.1")// 输出 code = 200, description = OKprint("code = http200Status. code, description = http200Status. description")// 输出同上 作为函数返回值时，元组非常有用。但是并不适合创建复杂的数据结构。元组在临时组织值的时候很有用，但是并不适合创建复杂的数据结构。如果你的数据结构并不是临时使用，请使用类或者结构体而不是元组。 可选类型使用可选类型（optionals）来处理值可能缺失的情况，可选类型可表示为有值 或者 无值两种情况。如：将一个 String 类型转换为 In t，若 String 为 “123” 则可以，为 “Hello world” 则会失败。 下面的例子使用这种构造器来尝试将一个 String 转换成 Int：12let possibleNum = 123let convertNum = Int(possibleNum) 因为该构造器可能会失败，所以它返回一个可选类型 Int? 而不是 Int ，问号暗示包含的值是可选类型，也就是说可能包含 Int 值也可能不包含值。 nil你可以给可选变量赋值为 nil 来表示它没有值:123var errorCode: Int? = 404errorCode = nil// 只有可选类型才可赋空值， nil 不能用于非可选的常量和变量 如果你声明一个可选常量或者变量但是没有赋值，它们会自动被设置为 nil。12var someNilStr: String?// someNilStr 被自动设为 nil Swift 的 nil 和 Objective-C 中的 nil 并不一样。Objective-C 中，nil 是一个指向不存在对象的指针。在 Swift 中，nil 不是指针——它是一个确定的值，用来表示值缺失。任何类型的可选状态都可以被设置为 nil，不只是对象类型 if 语句以及强制解析你可以使用 if 语句和 nil 比较来判断一个可选值是否包含值。你可以使用“相等”(==)或“不等”(!=)来执行比较1234if someNilStr == nil &#123; print("someNilStr 为 nil")&#125;// 输出：someNilStr 为 nil 当你确定可选类型确实包含值之后，可以在可选的名字后面加一个感叹号（!）来获取值，这被称为可选值的强制解析（forced unwrapping）12345var someNum: Int? = 123if someNum != nil &#123; print("someNum 的值为：\(someNum!)")&#125;// 输出：someNum 的值为：123 可选绑定使用可选绑定（optional binding）来判断可选类型是否包含值，如果包含就把值赋给一个临时常量或者变量。可选绑定可以用在 if 和 while 语句中。1234567var errorCode: Int? = 404if let newNum = Int(errorCode) &#123; print("errorCode 值为 \(newNum)")&#125; else &#123; print("errorCode 无值")&#125;// 输出 errorCode 值为 404 如果转换成功，errorCode 常量可以在 if 语句的第一个分支中使用。它已经被可选类型包含的值初始化过，所以不需要再使用 ! 后缀来获取它的值。可以在可选绑定中使用常量和变量，可将 let newNum = Int(errorCode) 改为 var newNum = Int(errorCode) 并在 if 语句的第一个分支中操作 newNum 的值。 可以包含多个可选绑定或多个布尔条件在一个 if 语句中，使用逗号分开。只要有任意一个可选绑定的值为 nil，或者任意一个布尔条件为 false，则整个if条件判断为false。(也可使用嵌套 if 语句来处理)1234if let firstNumber = Int("4"), let secondNumber = Int("42"), firstNumber &lt; secondNumber &amp;&amp; secondNumber &lt; 100 &#123; print("\(firstNumber) &lt; \(secondNumber) &lt; 100")&#125;// 输出 "4 &lt; 42 &lt; 100" 隐式解析可选类型当可选类型被第一次赋值之后就可以确定之后一直有值，这种类型的可选状态被定义为隐式解析可选类型（implicitly unwrapped optionals）。把想可选的类型的后面的问号（ String? ）改成感叹号（ String! ）来声明一个隐式解析可选类型。 隐式解析并不需要每次都使用解析来获取可选值。下面的例子展示了可选类型 String 和隐式解析可选类型 String 之间的区别。 1234let possibleString: String? = "An optional string."let forcedString: String = possibleString! // 需要感叹号来获取值let assumedString: String! = "An implicitly unwrapped optional string."let implicitString: String = assumedString // 不需要感叹号 隐式解析相当于一个特殊的可选类型，如果一个变量之后可能变成nil的话不能使用隐式解析，应使用可选类型。如果你在隐式解析可选类型没有值的时候尝试取值，会触发运行时错误。可使用 if 语句来把隐式解析可选类型当做普通可选类型来判断它是否包含值，也可以在可选绑定中使用隐式解析可选类型来检查并解析它的值。 错误处理可以使用 错误处理（error handling） 来应对程序执行中可能会遇到的错误条件。当一个函数遇到错误条件，它能报错。调用函数的地方能抛出错误消息并合理处理。123func canThrowAnError() throws &#123; // 这个函数有可能抛出错误&#125; 一个函数可以通过在声明中添加 throws 关键词来抛出错误消息。当你的函数能抛出错误消息时, 你应该在表达式中前置 try 关键词。123456do &#123; try canThrowAnError() // 没有错误消息抛出&#125; catch &#123; // 有一个错误消息抛出&#125; 一个 do 语句创建了一个新的包含作用域,使得错误能被传播到一个或多个 catch 从句。例子：1234567891011func makeASandwich() throws &#123; // ...&#125;do &#123; try makeASandwich() eatASandwich()&#125; catch SandwichError.outOfCleanDishes &#123; washDishes()&#125; catch SandwichError.missingIngredients(let ingredients) &#123; buyGroceries(ingredients)&#125; 使用断言进行调试断言（assertion）可以结束代码运行并通过调试来找到值缺失的原因。断言会在运行时判断一个逻辑条件是否为 true，如果条件判断为 true，代码运行会继续进行；如果条件判断为 false，代码执行结束，你的应用被终止。使用断言你可以清楚地看到不合法的状态发生在哪里并检查断言被触发时你的应用的状态。此外，断言允许你附加一条调试信息。 你可以使用全局 assert(::file:line:) 函数来写一个断言。向这个函数传入一个结果为 true 或者 false 的表达式以及一条信息，当表达式的结果为 false 的时候这条信息会被显示。1234let age = -3assert(age &gt;= 0, "A person's age cannot be less than zero")// -3 小于 0 ，所以断言会触发// 如果不需要断言信息 也可省略 assert(age &gt;= 0) 当代码使用优化编译的时候，断言将会被禁用，例如在 Xcode 中，使用默认的 target Release 配置选项来 build 时，断言会被禁用 何时使用断言当条件可能为假时使用断言，但是最终一定要保证条件为真，这样你的代码才能继续运行： 整数类型的下标索引被传入一个自定义下标实现，但是下标索引值可能太小或者太大。 需要给函数传入一个值，但是非法的值可能导致函数不能正常执行。 一个可选值现在是 nil，但是后面的代码运行需要一个非 nil 值。 断言可能导致你的应用终止运行，所以你应当仔细设计你的代码来让非法条件不会出现，但调试时使用断言可以快速发现问题。 持续更新中…]]></content>
      <categories>
        <category>Swift 学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 构建 Widget 应用全解（适配 iOS 10）]]></title>
    <url>%2F2016%2F10%2F25%2F2016%2FiOS-build-widget-app-complete-solution%2F</url>
    <content type="text"><![CDATA[iOS 8 出现的 Application Extension 极大的方便了用户查看应用的服务等信息。随着 iOS 10 的到来，苹果也越发重视 Widget 了，从锁屏页面，下拉通知栏的第一页，还有左滑主页面都可以进入 Widget。通过右上角的“展开”、“折叠”按钮，可以查看 Widget 的全部内容和部分内容。在 iPhone 6s 上面，点击应用 icon 的 3D Touch 界面中，也会有 Widget 的折叠界面的显示。 本文接下来要介绍的是如何在你的应用中接入 Today Extension，以及 Widget 的添加、UI 的绘制、主应用的吊起、Widget 和主应用数据的共享、针对 iOS 10 的适配等。 在工程中创建（添加）Widget在想要添加 Widget 的工程中执行以下操作Xcode 菜单 -&gt; File -&gt; New -&gt; Target… -&gt; 选择 Today Extension，如下所示。 创建完之后多出 Widget 的文件夹及内容，名字默认为 TodayViewController 可自行修改。至此，为工程添加 Widget 就算成功了，运行工程就可以看到 Widget 的效果了。 Widget 的使用绘制 UI使用 Interface Builder。工程默认的方式就是使用 Interface Builder，如果实现简单的布局的话可以考虑这种方式。 使用代码进行布局。使用代码需要修改一下 widget 下的 plist 文件。首先将原有 NSExtensionMainStoryboard 字段删除，添加字段 NSExtensionPrincipalClass ，value 是你所写的 controller 的名称，一般默认的都是 TodayViewController。 设置 Widget 的 sizeiOS 10 之后，Widget 支持展开及折叠两种展现方式，通过设置widgetLargestAvailableDisplayMode 属性可以让 Widget 程序实现展开布局。1234567891011- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view from its nib. if ([UIDevice currentDevice].systemVersion.doubleValue &gt;= 10.0) &#123; // iOS 10 以后 self.extensionContext.widgetLargestAvailableDisplayMode = NCWidgetDisplayModeExpanded; &#125; self.preferredContentSize = CGSizeMake(kWidgetWidth, 110);&#125; 重写切换展开及折叠布局时的方法（iOS 10 以后）。123456789101112- (void)widgetActiveDisplayModeDidChange:(NCWidgetDisplayMode)activeDisplayMode withMaximumSize:(CGSize)maxSize&#123; NSLog(@"maxWidth %f maxHeight %f",maxSize.width,maxSize.height); if (activeDisplayMode == NCWidgetDisplayModeCompact) &#123; self.preferredContentSize = CGSizeMake(maxSize.width, 110); &#125; else &#123; self.preferredContentSize = CGSizeMake(maxSize.width, 200); &#125;&#125; iOS 10 之前绘制的内容与左侧边界有一定距离(约30px)。可用以下方法解决（iOS 10）不存在此问题。1234- (UIEdgeInsets)widgetMarginInsetsForProposedMarginInsets:(UIEdgeInsets)defaultMarginInsets&#123; return UIEdgeInsetsMake(0, 10, 0, 10);&#125; 唤起应用因为 extension 和 containing app 是两个完全独立的进程，所以它们之间不能直接通信(不能像应用内部点击按钮，跳转到指定页面)。为了实现 widget 调起 app，这里通过 openURL 的方式来启动 containing app。 为你的应用设置它的 URL Scheme。 使用以下代码来打开主应用，其中 appextension://xxx 为你的应用的 URL Scheme，如果想要快速启动微信换成 wechat:// 即可，其他的应用全部类似。123456- (void)openURLContainingAPP&#123; //通过 extensionContext 借助 host app 调起 app [self.extensionContext openURL:[NSURL URLWithString:@"appextension://xxx"] completionHandler:^(BOOL success) &#123; NSLog(@"open url result:%d",success); &#125;];&#125; 相应的，在 AppDelegate 中实现以下方法，这里可以处理传过来的 action，对于传过来不同的值可以进行不同的操作。12345678- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation&#123; if ([[url absoluteString] hasPrefix:@"appextension"]) &#123; // 处理你的事情 &#125; return YES;&#125; 数据的共享扩展程序一般都不是脱离宿主程序单独运行的，难免需要和宿主程序进行数据交互。而相对于一般的 App，数据可以用单例，NSUserDefault 等等。但由于拓展与宿主应用是两个完全独立的 App，并且iOS应用基于沙盒的形式限制，所以一般的共享数据方法都是实现不了数据共享，这里就需要使用 App Groups。 widget 也是需要单独申请 App id 的，需要配置证书和 Provisioning Profiles文件，到你的开发者中心后台分别添加宿主程序和 widget 程序的 App id，widget 程序的 Bundle id 需以主程序的 Bundle id 为前缀，例如 com.xxx 和 com.xxx.widget 。添加完成后需要在后台创建 App Groups 并包含两个 Bundle id 。 打开应用的 Capabilities， 找到 App Groups 选项，勾选建立好的 group ，Steps 全部没问题即可。 两种数据存储方式 使用 NSUserDefault这里不能使用 [NSUserDefaults standardUserDefaults]; 方法来初始化 NSUserDefault 对象，正像之前所说，由于沙盒机制，拓展应用是不允许访问宿主应用的沙盒路径的，因此上述用法是不对的，需要搭配 app group 来实例化 UserDefaults 。 1234567// 写入数据NSUserDefaults *userDefaults = [[NSUserDefaults alloc] initWithSuiteName:@"group.com.snaillove.app.tool.quickpay"];[userDefaults setObject:self.textField.text forKey:@"widget"];[userDefaults synchronize];// 读取数据NSUserDefaults *userDefaults = [[NSUserDefaults alloc] initWithSuiteName:@"group.com.snaillove.app.tool.quickpay"];self.contentStr = [userDefaults objectForKey:@"widget"]; 使用 NSFileManager 共享数据写入数据 和 读取数据。 123456789101112131415161718192021222324252627// 写入数据-(BOOL)saveDataByNSFileManager&#123; NSError *err = nil; NSURL *containerURL = [[NSFileManager defaultManager] containerURLForSecurityApplicationGroupIdentifier:@"group.com.xxx"]; containerURL = [containerURL URLByAppendingPathComponent:@"Library/Caches/ widget"]; NSString *value = @"asdfasdfasf"; BOOL result = [value writeToURL:containerURL atomically:YES encoding:NSUTF8StringEncoding error:&amp;err]; if (!result) &#123; NSLog(@"%@",err); &#125; else &#123; NSLog(@"save value:%@ success.",value); &#125; return result;&#125;// 读取数据-(NSString *)readDataByNSFileManager&#123; NSError *err = nil; NSURL *containerURL = [[NSFileManager defaultManager] containerURLForSecurityApplicationGroupIdentifier:@"group.com.xxx"]; containerURL = [containerURL URLByAppendingPathComponent:@"Library/Caches/ widget"]; NSString *value = [NSString stringWithContentsOfURL:containerURL encoding: NSUTF8StringEncoding error:&amp;err]; return value;&#125; 注意事项Widget 因为有自己的 App id，所以也需要一套自己的配置文件(不同于 host 应用的)。如果发现 widget 应用没有 AppIcon ，则需要在 AppIcon 的 Target Memberhip 选项中勾选 widget 应用。 同样默认 widget 应用是无法使用宿主应用的类和资源文件的，如果想要使用的话同上面 AppIcon 方法一样，Target Memberhip 选项中勾选 widget 应用即可。 到此，iOS 构建 Widget 就基本 ok 了。待续……]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>Widget 应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 打 ipa 包的几种实用方法]]></title>
    <url>%2F2016%2F08%2F21%2F2016%2FiOS-achive-ipa-package-methods%2F</url>
    <content type="text"><![CDATA[iOS 开发中无论是提交你的应用到 App Store，打 Ad Hoc 测试包，还是制作企业版二维码下载，都需要导出 ipa 包。下面介绍几种打 ipa 包的实用方法。 使用 Xcode 的 Archive 功能（ Apple 推荐的方式）选择 Xcode 菜单 —&gt; Archive —&gt; 完成后 Export —&gt; Ad Hoc 然后选择你的开发者账号和保存位置导出即可，如下： 局限性：一般多人开发时都是采用 provisioning profile + P12 文件来进行真机调试，上述方法在最后导出 ipa 包时需要输入 AppleID，到这一步采用 provisioning profile + P12 真机调试的方式由于账号权限 Xcode 配置等原因可能会导致相关问题不能导出。如以下等问题： 除了这种方式外，还有其他比较实用的四种方法，接下来主要介绍这几种方法。 通过 iTunes 导出(推荐)这种方式是在 Xcode 编译产生出 .app 包的基础上进行进一步处理，通过简单的压缩以及改后缀名即可实现 ipa 打包。直接打印 [NSBundle mainBundle] 目录，然后打开次目录，会看到将目录下有应用的 .app 文件。 将得到的 .app 文件直接拖动到 iTunes 中，就会在 itunes 中自动生成 ipa, 然后选中生成的 ipa，再直接拖动到桌面，在桌面就生成 ipa 文件了。 修改后缀名为 .ipa道理同方法一。 新建名为了 “Payload” 的文件夹，注意名字要一字不差。 将你的 .app 包放到P ayload 文件夹中，注意 app 的名字不做任何更改，就用 Xcode 生成的 app 名称。 在 Payload 文件夹上右键压缩成 zip，然后将生成的 .zip 文件后缀改成 .ipa 即可。 命令行实现打包 打开终端，到需要打包的工程目录下，即 .xcodeproj 工程文件目录下。 执行 xcodebuild clean 命令。 然后执行 xcodebuild -target ** -configuration Release，其中 ** 为你的应用名，这个过程可能需要等待一会。 完成后在终端输入 xcrun -sdk iphoneos PackageApplication -v ** -o ##，然后回车，即可在指定的目录下得到 .ipa 文件： -v 后面的 ““ 为上一条命令执行后得到的路径，也就是 build 后 .app 文件的路径，如图7，我的为： /Users/lihongyuan/Desktop/LangQin/build/Release-iphoneos/.app -o 后面的 “##” 为到出 ipa 文件的完成路径，可自定义。 第三步过后会发现工程目录下多出一个build文件夹，然后 build -&gt; Release -&gt; iphoneos 找到下面的 .app 文件： 终端输入 xcrun -sdk iphoneos PackageApplication -v + 空格，然后把 .app 文件直接拖进终端，因为现在已经在当前路径下了。在终端继续输入 -o + 空格，然后把 .app 文件直接拖进终端，然后把 .app 改为 .ipa，回车，在 .app 文件当前的路径下，发现生成了 .ipa 文件: 脚本实现编写一个全自动编译脚本，从而不用打开 Xcode 编译运行即可实现打包，这种方法也十分快捷，一劳永逸，这里不具体展开。缺点：不出错还好，一旦有语法错误或者其他错误出现就不好处理。]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS 关于 GCD 的详细介绍和基本用法]]></title>
    <url>%2F2016%2F06%2F20%2F2016%2FiOS-GCD-introduce-and-usage%2F</url>
    <content type="text"><![CDATA[什么是 GCD ？ GCD 的简介GCD 是 “Grand Central Dispatch” 的简称，是一套底层 API ，提供了一种新的方法来进行并发程序编写。从基本功能上讲，GCD 有点像 NSOperationQueue ，他们都允许程序将任务切分为多个单一任务然后提交至工作队列来并发地或者串行地执行。GCD 比之 NSOpertionQueue 更底层更高效，并且它不是 Cocoa 框架的一部分。 GCD 是为多核的并行运算提出的解决方案，除了代码的平行执行能力，GCD 还提供高度集成的事件控制系统。可以设置句柄来响应文件描述符、mach ports（Mach port 用于 OS X 上的进程间通讯）、进程、计时器、信号、用户生成事件。这些句柄通过 GCD 来并发执行。 GCD 的 API 很大程度上基于 block ，当然，GCD 也可以脱离 block 来使用，比如使用传统 c 机制提供函数指针和上下文指针。实践证明，当配合 block 使用时，GCD 非常简单易用且能发挥其最大能力。 GCD 的工作原理：让程序平行排队的特定任务，根据可用的处理资源，安排他们在任何可用的处理器核心上执行任务。一个任务可以是一个函数 (function) 或者是一个 block。GCD 的底层依然是用线程实现，不过这样可以让程序员不用关注实现的细节。 GCD 的优势 易用： GCD 比之 thread 更加简单易用。由于 GCD 基于 work unit 而非像 thread 那样基于运算，所以 GCD 可以控制诸如等待任务结束、监视文件描述符、周期执行代码以及工作挂起等任务。基于 block 的血统导致它能极为简单得在不同代码作用域之间传递上下文。 效率： GCD 被实现得如此轻量和优雅，使得它在很多地方比之专门创建消耗资源的线程更实用且快速。这关系到易用性：导致 GCD 易用的原因有一部分在于你可以不用担心太多的效率问题而仅仅使用它就行了。 性能： GCD 自动根据系统负载来增减线程数量，这就减少了上下文切换以及增加了计算效率。 GCD 的使用步骤和核心概念核心概率有 2 个 队列：用来存放任务 任务：执行什么操作 使用步骤有2步 定制任务 确定想做的事情 GCD 的核心工作原理 任务和队列任务即操作，你想要干什么，说白了就是一段代码，在 GCD 中就是一个 Block，所以添加任务十分方便。任务有两种执行方式： 同步执行 和 异步执行，同步（sync） 和异步（async） 的主要区别在于会不会阻塞当前线程，直到 Block 中的任务执行完毕。 同步执行：它会阻塞当前线程并等待 Block 中的任务执行完毕，然后当前线程才会继续运行。 异步执行：当前线程会直接往下执行，它不会阻塞当前线程。 队列用于存放任务。系统提供了两个队列，一个是 MainDispatchQueue，一个是 GlobalDispatchQueue， 即 串行队列和并行队列。 串行队列：放到串行队列的任务，GCD 会 FIFO（先进先出） 地取出来一个，执行一个，然后取下一个，这样一个一个的执行。会将任务插入主线程的 RunLoop 当中去执行，我们可以使用它来更新 UI。 并行队列：放到并行队列的任务，GCD 也会 FIFO 的取出来，但不同的是，它取出来一个就会放到别的线程，然后再取出来一个又放到另一个的线程。这样由于取的动作很快，忽略不计，看起来，所有的任务都是一起执行的。不过需要注意，GCD 会根据系统资源控制并行的数量，所以如果任务很多，它并不会让所有任务同时执行。有高、默认、低和后台 4 个优先级。 创建队列主队列：这是一个特殊的串行队列。什么是主队列，大家都知道吧，它用于刷新 UI，任何需 要刷新 UI 的工作都要在主队列执行，所以一般耗时的任务都要放到别的线程执行。1dispatch_queue_t mainQueue = dispatch_get_main_queue(); 全局并行队列只要是并行任务一般都加入到这个队列。这是系统提供的一个并发队列。1dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); 自己创建的队列可以是串行队列，也可以创建并行队列。看下面的代码，它有两个参数，第一个为标识，第二个才是最重要的。传入 DISPATCH_QUEUE_SERIAL 或 NULL 表示创建串行队列。传入 DISPATCH_QUEUE_CONCURRENT 表示创建并行队列.1234// 串行队列dispatch_queue_t serialQueue = dispatch_queue_create("SerialQueue", DISPATCH_QUEUE_SERIAL);// 并行队列dispatch_queue_t concurrentQueue = dispatch_queue_create("ConcurrentQueue", DISPATCH_QUEUE_CONCURRENT); 创建任务同步任务会阻塞当前线程 (Sync) 。1234dispatch_sync(queue, ^&#123; //code here NSLog(@"%@", [NSThread currentThread]);&#125;); 异步任务：不会阻塞当前线程 (Async) 。1234dispatch_async(&lt;#queue#&gt;, ^&#123; //code here NSLog(@"%@", [NSThread currentThread]);&#125;); 线程dispatch_asyn 和 dispatch_sync 添加任务到 dispatch 队列时，是否创建线程呢，那么创建线程是创建一个呢还是多个呢? dispatch_sync 添加任务到队列，不会创建新的线程都是在当前线程中处理的。无论添加到串行队列里或者并行队列里，都是串行效果，因为这个方法是等任务执行完成以后才会返回。 dispatch_async 添加任务到 mainQueue 不创建线程，在主线程中串行执行。 globalQueue 和 并行队列：根据任务系统决定开辟线程个数。 串行对列：创建一个线程：串行执行。 具体看下表： 同步执行 异步执行 串行队列 当前线程，一个一个执行 其他线程，一个一个执行 并行队列 当前线程，一个一个执行 开很多线程，一起执行 GCD 的基本使用延迟执行 dispatch_after不需要再写方法，且它还传递了一个队列，我们可以指定并安排其线程。如果队列是主队列，那么就在主线程执行，如果队列是并发队列，那么会新开启一个线程，在子线程中执行。123456NSLog(@"打印当前线程---%@", [NSThread currentThread]);// 延迟执行, 这段代码将会在2秒后将任务插入 RunLoop 当中dispatch_queue_t queue= dispatch_get_main_queue();dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), queue, ^&#123; NSLog(@"主队列--延迟执行------%@",[NSThread currentThread]);&#125;); 一次性执行代码 dispatch_once整个程序运行过程中，只会执行一次。单例对象创建的方法。12345// 一次性执行：使用 dispatch_once 一次性代码static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123; NSLog(@"该行代码只执行一次");&#125;); 多线程编程上面已经提过队列一般就是系统的 主队列 和 全局队列 还有自己手动创建的串行队列和并行队列:1234dispatch_queue_t serialQueue = dispatch_queue_create("SerialQueue", DISPATCH_QUEUE_SERIAL); // 串行队列dispatch_queue_t concurrentQueue = // 并行队列dispatch_queue_create("ConcurrentQueue",DISPATCH_QUEUE_CONCURRENT);dispatch_queue_t mainQueue = dispatch_get_main_queue(); // 主队列dispatch_queue_t globalQueue = dispatch_get_global_queue(0, 0); // 全局队列 方法有两个 dispatch_sync 和 dispatch_async 。12dispatch_sync // 立刻返回的，也就是说把 block 内容加到相应队列里后会立马返回。dispatch_async // 要等到加到队列里执行完之后才会返回。 这时候总共有 2*4 = 8 种组合，接下来我们来说一下这八种组合。 1. 串行队列同步执行第一种方式可见，串行队列是在主线程里完成的，因为是串行队列，所以打印 %d 是有顺序的。12345for(int i = 0; i &lt; 3; i++)&#123; dispatch_sync(serialQueue, ^&#123; NSLog(@"串行队列同步执行:%d\n mainThread:%@",i,[NSThread currentThread]); &#125;);&#125; 2. 并行队列同步执行这种方式可以发现同样还是在主线程里执行并行队列，(虽然是并行队列，但这时候依然在同一个线程里执行)。12345for(int i = 0; i &lt; 3; i++)&#123; dispatch_sync(concurrentQueue, ^&#123; NSLog(@"并行队列同步执行:%d\n mainThread:%@",i,[NSThread currentThread]); &#125;);&#125; 3. 主队列同步执行(线程阻塞)打印结果: 发现只打印了一条，同步执行, 发现主线程被堵塞。因为此时 mainQueue 里存在任务 1，同步线程任务，当执行 dispatch_sync 时，把打印任务 2 加入主队列，想要打印 2 必须等之前所有的任务都执行完成，这时候因为主队列里有同步线程任务，这时候相当于自己在等自己执行完成，进入死循环。123456for(int i = 0; i &lt; 3; i++)&#123; NSLog(@"任务 1"); dispatch_sync(mainQueue, ^&#123; NSLog(@"任务2: 主队列同步执行:%d\n mainThread:%@",i,[NSThread currentThread]); &#125;);&#125; 4. 全局队列同步执行打印结果可以看出依然是主线程。12345for(int i = 0; i &lt; 3; i++)&#123; dispatch_sync(globalQueue, ^&#123; NSLog(@"全局队列同步执行:%d\n mainThread:%@",i,[NSThread currentThread]); &#125;);&#125; 5. 串行队列异步执行可以看出创建了一个线程, 在串行队列里串行执行的 sleep 函数延时执行: [NSThread sleepForTimeInterval:1.0f] ，此方式在主线程和子线程中均可执行，是一种阻塞的执行方式，建方放到子线程中，以免卡住界面。12345678for (int i = 0; i &lt; 3; i++) &#123; dispatch_async(chuanxingduilie, ^&#123; f (i == 1) &#123; sleep(2); &#125; NSLog(@"串行队列异步执行: %d\n Thread:%@",i,[NSThread currentThread]); &#125;);&#125; 6. 并行队列异步执行可以看出创建了多个线程，任务执行顺序不一定（时间差不多的话），这和 cpu 的处理和性能有关。12345678for (int i = 0; i &lt; 3; i++) &#123; dispatch_async(bingxingduilie, ^&#123; if (i==1) &#123; sleep(2); &#125; NSLog(@"并行队列异步执行: %d\n Thread:%@",i,[NSThread currentThread]); &#125;);&#125; 7. 主队列异步执行可以看出这种情况还是在当前线程（主线程）环境中执行，并不创建线程，因为是在主队列里，顺序执行。12345678for (int i = 0; i &lt; 3; i++) &#123; dispatch_async(mainQueue, ^&#123; if (i==1) &#123; sleep(3); &#125; NSLog(@"主队列异步执行: %d\n Thread:%@",i,[NSThread currentThread]); &#125;);&#125; 8. 全局队列异步执行可以看出创建了多个线程，执行顺序并不一定。12345678for (int i = 0; i &lt; 3; i++) &#123; dispatch_async(globalQueue, ^&#123; if (i==1) &#123; sleep(3); &#125; NSLog(@"全局队列异步执行: %d\n Thread:%@",i,[NSThread currentThread]); &#125;);&#125; 队列组 dispatch_group队列组可以将很多队列添加到一个组里，这样做的好处是，当这个组里所有的任务都执行完了，列组会通过一个方法通知我们，这是一个很实用的功能。12345678910111213141516171819// dispatch_groupdispatch_queue_t globalQueue1 = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_group_t group = dispatch_group_create(); dispatch_group_async(group, globalQueue1, ^&#123; // sleep(1); NSLog(@"1"); &#125;); dispatch_group_async(group, globalQueue1, ^&#123; // sleep(2); NSLog(@"2"); &#125;); dispatch_group_async(group, globalQueue1, ^&#123; // sleep(3); NSLog(@"3"); &#125;); // 保证此处为最后执行 dispatch_group_notify(group, globalQueue1, ^&#123; NSLog(@"Over!");&#125;); dispatch_barrier_async下面内容翻译自官方文档： 一个 dispatch barrier 允许在一个并发队列中创建一个同步点。当在并发队列中遇到 barrier，他会延迟执行barrier的block，等待所有在barrier之前提交的blocks执行结束。 这时，barrier block 自己开始执行。 之后，队列继续正常的执行操作。12345678910111213141516171819202122// dispatch_barrier_asyncdispatch_queue_t concurrentQueue = dispatch_queue_create("my.concurrent.queue", DISPATCH_QUEUE_CONCURRENT);dispatch_async(concurrentQueue, ^()&#123; NSLog(@"dispatch-1");&#125;);dispatch_async(concurrentQueue, ^()&#123; NSLog(@"dispatch-2");&#125;);// 保证 1+2 在执行完 1 和 2 的时候执行dispatch_barrier_async(concurrentQueue, ^()&#123; NSLog(@"dispatch-barrier-1+2");&#125;);dispatch_async(concurrentQueue, ^()&#123; NSLog(@"dispatch-3");&#125;);// 保证 1+2+3 在执行完 1 和 2 和 3 的时候执行dispatch_barrier_async(concurrentQueue, ^&#123; NSLog(@"dispatch-barrier-1+2+3");&#125;);dispatch_async(concurrentQueue, ^()&#123; NSLog(@"dispatch-4");&#125;); 暂停和恢复可以使用 dispatch_suspend(queue) 可以暂停队列中任务的执行，使用 dispatch_result(queue) 可以继续执行被暂停的队列。 使用过程中的注意事项 dispatch_once_t 必须是全局或 static 变量非全局或非 static 的 dispatch_once_t 变量在使用时会导致非常不好排查的 bug，正确的如下：1234static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; // code&#125;); 其实就是保证 dispatch_once_t 只有一份实例。 dispatch_after 是延迟提交，不是延迟运行官方文档的说明： Enqueue a block for execution at the specified time.Enqueue，就是入队，指的就是将一个 Block 在特定的延时以后，加入到指定的队列中，不是在特定的时间后立即运行。 正确创建 dispatch_time_t用 dispatch_after 的时候就会用到 dispatch_time_t 变量，但是如何创建合适的时间呢？答案就是用dispatch_time 函数，其原型如下：1dispatch_time_t dispatch_time ( dispatch_time_t when, int64_t delta); 第一个参数一般是 DISPATCH_TIME_NOW，表示从现在开始，那么第二个参数就是真正的延时的具体时间。这里要特别注意的是，delta 参数是 “纳秒”，延时 1 秒 delta 应该是 “1000000000” ，所以理所当然系统提供了常量:123#define NSEC_PER_SEC 1000000000ull // NSEC_PER_SEC，每秒有多少纳秒。#define USEC_PER_SEC 1000000ull // USEC_PER_SEC，每秒有多少毫秒。#define NSEC_PER_USEC 1000ull // NSEC_PER_USEC，每毫秒有多少纳秒。 所以，延时 1 秒可以写成如下几种：123dispatch_time(DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC);dispatch_time(DISPATCH_TIME_NOW, 1000 * USEC_PER_SEC);dispatch_time(DISPATCH_TIME_NOW, USEC_PER_SEC * NSEC_PER_USEC); dispatch_suspend != 立即停 止队列的运行dispatch_suspend，dispatch_resume 提供了 “挂起、恢复” 队列的功能，简单来说，就是可以暂停、恢复队列上的任务。但是 dispatch_suspend 并不会立即暂停正在运行的 block，而是在当前 block 执行完成后，暂停后续的 block 执行。 避免死锁1. dispatch_sync 导致的死锁涉及到多线程的时候，不可避免的就会有 死锁 这个问题，在使用 GCD 时，往往一不小心，就可能造成死锁。 2. dispatch_apply 导致的死锁dispatch_apply 的作用是在一个队列（串行或并行）上“运行”多次 block，其实就是简化了用循环去向队列依次添加 block 任务。dispatch_apply 也会导致的死锁。看如下例子：123456789// 这端代码只会输出“apply loop: 1”// 所以，一定要避免dispatch_apply的嵌套调用。dispatch_queue_t queue = dispatch_queue_create("me.tutuge.test.gcd", DISPATCH_QUEUE_SERIAL); dispatch_apply(3, queue, ^(size_t i) &#123; NSLog(@"apply loop: %zu", i); // 再来一个dispatch_apply就会导致死锁。 dispatch_apply(3, queue, ^(size_t j) &#123; NSLog(@"apply loop inside %zu", j); &#125;);&#125;); 灵活使用 dispatch_group很多时候我们需要等待一系列任务（block）执行完成，然后再做一些收尾的工作。如果是有序的任务，可以分步骤完成的，直接使用串行队列就行。但是如果是一系列并行执行的任务呢？这个时候，就需要 dispatch_group。dispatch_group 的使用分如下几步： 创建 dispatch_group_t 添加任务（block） 添加结束任务（如清理操作、通知UI等） 使用 dispatch_barrier_async 和 dispatch_barrier_sync 的注意事项dispatch_barrier_async 的作用就是向某个队列插入一个 block，当目前正在执行的 block 运行完成后，阻塞这个 block 后面添加的 block，只运行这个 block 直到完成，然后再继续后续的任务。 值得注意的是： dispatch barrier (a)sync 只在自己创建的并发队列上有效。 在全局 (Global) 并发队列、串行队列上，效果跟dispatch_(a)sync 效果一样。 在串行队列上跟 dispatch_(a)sync 效果一样，那就要小心线程锁死。]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>GCD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 如何优化 ipa 程序安装包的大小]]></title>
    <url>%2F2016%2F05%2F17%2F2016%2FiOS-ipa-volume-decrease%2F</url>
    <content type="text"><![CDATA[iOS 开发中最终需要的结果便是 ipa 应用包，ipa 应用包自然也是越小越好，下面介绍了 iOS 优化 ipa 安装包大小的几种方法。 配置编译选项 Genetate Debug Symbols 设置为 NOGenerate Debug Symbols 这个设置在 DEBUG 和 RELEASE下 均默认为 YES。当 Generate Debug Symbols 设置为 YES 时，编译产生的 .o 文件会大一些，当然最终生成的可执行文件也大一些。当 Generate Debug Symbols 设置为 NO 的时候，在 Xcode 中设置的断点不会中断，同样生成的 ipa 安装包也会小一些。 适当舍弃架构 armv7因为 armv7 用于支持 4s 和 3gs ，4s 是 2011 年 11 月正式上线，虽然还有小部分人在使用，如果是是追求包体大小的完全可以舍弃了。 删除无用的图片音频和视频文件ipa 包的体积增大很大程度上取决于资源文件的大小。包括 Images.xcassets 中无用的图片， bundle 中的音频、视频、图片 和字体文件等。 Optimization Level 等编译项优化 Build Settings -&gt; Optimization Level 有几个编译优化选项，release 版应该选择 Fastest, Smalllest ，这个选项会开启那些不增加代码大小的全部优化，并让可执行文件尽可能小。 Strip Linked Product / Deployment Postprocessing / Symbols Hidden by Default 在 release 版本应该设为 YES ，可以去除不必要的调试符号。Symbols Hidden by Default 会把所有符号都定义成 ”private extern” 。 这些选项目前都是 XCode 里 release 的默认选项，但旧版 XCode 生成的项目可能不是，可以检查一下。 附: 如何查看 ipa 包中的大文件 找到自己打包后的 ipa ，然后右键，打开方式选择归档实用工具，就会解压出来一个名为 Payload 文件夹。 在 Payload 文件夹中找到当前 ipa 的 app 文件（基本就是和这个ipa名字一样的文件，app 后缀系统默认隐藏），右键显示包内容。 进入到文件夹内，按照大小进行排序，你会发现所有的资源。 附: 查找 iOS 工程无用图片资源工具LSUnusedResources 点击 Browse，选择一个文件夹。 点击 Search 开始搜索。 等待片刻即可看到结果，可直接对搜索结果进行操作。 注意针对减小 ipa 包体积的操作，我们必须考虑相关影响，以确保做出正确的决定。如果不做权衡的话，我们无法知道需要对程序做出什么样的改变。]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>ipa 优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 使用 Xcode 彻底修改项目名（包含修改 CocoaPods 项目名）]]></title>
    <url>%2F2016%2F03%2F24%2F2016%2FiOS-modify-project-name-entirely%2F</url>
    <content type="text"><![CDATA[在 iOS 开发中，有时候两个项目有很多相似的地方，与其新建一个项目,不如直接在老项目的基础上修改，而修改项目的名字，会遇到很多麻烦，总是有很多文件、文件夹或者是项目设置项。而且都是不能随便改的，很多地方都会导致程序编译不了。下面的方法可以彻底修改项目的名字，你不会再看到任何有关于之前的项目名字。 做好备份重命名项目时，记得先备份好一份。这里我将工程 TextDemo 重命名为 FormalDemo 。 变更项目名称打开 TextDemo.xcworkspace，如果没有使用 CocoaPods 就使用 TextDemo.xcodeproj 打开工程。直接将 TextDemo 命名为 FormalDemo 。 在弹出的窗口中选择 Rename 。 修改文件夹名称将 TextDemo 和 TextDemoTests 分别修改为 FormalDemo 和 FormalDemoTests 。 修改类 TextDemoTests.m更改类名字时不能直接重命名，需要使用Xcode内置的更改类名功能。点击 @interface 后面的类名： Menu -&gt; Edit -&gt; Refactor -&gt; Rename 。 点击 Save 就可以了。 全局搜索替换成新项目名字此时目录名字都更换完成了，但是编译是不通过的，因为 Xcode 指向的还是之前的名字。接下来全局搜索旧的名字并替换成新的名字，这里只是替换一下注释。 再次搜索旧的项目名，有些是需要我们手动修改的。 更改项目根目录下的文件夹名字并重新指定路径打开项目文件夹，继续更改文件夹名字。 修改完后，发现工程的文件全部变红了。 接下来，需要重新指定文件路径，选择文件夹 FormalDemo 。 点击文件夹图标。 在弹出的窗口中选择我们刚刚命名好的文件夹。 同样的方法重新指定 FormalDemoTests，然后发现红色的文件又都变回来了。 完成修改然后重新编译，发现已经可以通过了，至此名字就完全修改过来了。修改后的目录结构： CocoaPods 项目重命名如果项目使用了 CocoaPods 管理第三方框架，重命名 CocoaPods 项目时。需要先将项目中的 CocoaPods 环境移除掉，然后按照上面的方法对工程进行重命名，然后再重新安装 CocoaPods 。 移除相关 pod 文件删除工程根目录文件夹下的 Podfile、Podfile.lock 及 Pods 文件夹，其中 Podfile 文件可以先备份一份，因为还要重新装回来。 删除xcworkspace文件删除工程根目录文件夹下 xxx.xcworkspace 文件。 删除 Pods.xcconfig 及 libPods.a 的引用使用 xxx.xcodeproj 文件打开工程，删除 Frameworks 组下的 Pods.xcconfig 及 libPods.a 文件的引用。 删除 Build Phases 中的配置项在工程设置中的 Build Phases 下删除 Check Pods Manifest.lock 、 Copy Pods Resources 和 Enable Pods Frameworks 选项。 使用插件移除工程中的 CocoaPods 环境手动卸载 CocoaPods 是件相对麻烦的事情，各种删除文件，又要打开项目设置各种配置信息，有时候还可能会报错。所有可以使用插件 cocoapods-deintegrate 来卸载 CocoaPods 。 1、首先打开终端在终端输入：1sudo gem install cocoapods-deintegrate 安装成功后会有以下提示：123Successfully installed cocoapods-deintegrate-0.2.1 Parsing documentation for cocoapods-deintegrate-0.2.1 1 gem installed 2、从终端进入到你的项目的根目录，然后执行：1pod deintegrate 成功后会有如下提示：12345678910111213141516Deintegrating Test.xcodeproj Deintegrating target Test Deleted 1 'Copy Pods Resources' build phases. Deleted 1 'Check Pods Manifest.lock' build phases. Deleted 1 'Embed Pods Frameworks' build phases. Removing Pod libraries from build phase: - libPods.aDeleting Pod file references from project - Pods.debug.xcconfig- Pods.release.xcconfig- libPods.aDeleted 1 empty `Pods` groups from project. Deleted 1 empty `Frameworks` groups from project. Removing `Pods` directory.Project has been deintegrated. No traces of CocoaPods left in project. Note: The workspace referencing the Pods project still remains. 3、至此，CocoaPods 已经完全从你的项目中移除了，但 CocoaPods 的文件还是存在的，手动删除更目录下的 Podfile、Podfile.lock 和 .xcworkspace 文件即可。 补充点修改 PCH 文件和其路径如果工程中有 PCH 文件还需要重命名 PCH 文件，并重新指定其路径。 修改 Library 和 Framework 搜索路径改名后编译报 warning: directory not found for option 这样的错误（原因是找不到链接的库或者文件）。选择工程 targets -&gt; Build Settings 将其中的 Framework Search Paths 和 Library Search Paths 这两项重新指定正确的路径即可。 修改 Scheme 名称点击要编辑的 Scheme，然后选择 Edit Scheme… 在弹出的窗口中选择 Manage Schemes… ，然后直接回车编辑即可。 待续…]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CocoaPods 的安装使用和常见问题]]></title>
    <url>%2F2016%2F01%2F27%2F2016%2FiOS-CocoaPods-usage-and-problem%2F</url>
    <content type="text"><![CDATA[CocoaPods 是一个负责管理 iOS 项目中第三方开源库的工具，iOS 开发不可避免地要使用第三方开源库，CocoaPods 的出现使得我们可以节省设置和更新第三方开源库的时间，下面将介绍如何安装使用 CocoaPods 以及一些常见问题的解决方案。 CocoaPods 安装步骤Ruby 环境搭建CocoaPods 是用 Ruby 写的，使用 CocoaPods 需要 Ruby 环境，Mac OS 本身自带 Ruby，但最好还是更新一下，因为升级了系统之后，可能会出现一些意想不到的情况，首先打开终端 Terminal 。 查看下当前ruby版本： ruby -v 。 升级ruby： sudo gem update —system 。 由于国内防火墙限制我们，可以用淘宝的Ruby镜像来访问CocoaPods。终端输入如下命令： 123gem sources –remove https://rubygems.org/ 。gem sources -a https://ruby.taobao.org/ 。gem sources -l （用来检查使用替换镜像位置成功）。 下载安装 CocoaPods 命令： sudo gem install cocoapods，Mac OS 10.11 以上系统使用命令： sudo gem install -n /usr/local/bin cocoapods。 使用搜索命令 pod search AFNetworking 查找某一个库，看 CocoaPods 有没有安装好，如下便安装成功。 CocoaPods的使用进入到工程根目录打开项目所在的文件夹，在终端敲入 cd Desktop/CocoaPodsText 或将文件夹拖拽到终端，进入到项目所在文件夹（根目录）。 建立 Podfile (配置文件) 终端输入： vim Podfile 。 接着输入： i 进入 insert 模式。 内容按这个格式输入：12345target ‘YourProjectName’ do pod ‘MBProgressHUD’ pod ‘ASIHTTPRequest’, ‘~&gt; 1.8.2’ pod ‘SDWebImage’, ‘~&gt; 3.7.3’end 如果你不知道这些框架目前的版本是，可以使用命令 pod search + 框架名称 查看相应的信息，不写版本默认为框架的最新版本。 然后按 Esc ，并且输入 shift + ：号进入 vim 命令模式，然后在冒号后边输入 wq ，按回车键，保存并且退出，完成后会发现对应项目根目录中多一个 Podfile 文件。 Podfile 文件的创建编辑可以使用终端操作，也可直接创建文件打开文件编辑。 安装第三方类库终端 cd 到项目根目录小，然后输入 pod install，等待一会，框架就自动安装好了，如图所示，多出了4个文件夹/文件夹。 注意：现在打开项目不是点击 podTest.xodeproj 了，而是点击 podsTest.xcworkspace (白的图标)。 常用命令 pod install –no-repo-update –verbose 关掉索引更新并安装且体现下载过程。 pod install –no-repo-update —verbose 同为需要添加删除时。 pod update –no-repo-update —verbose 更新 pod (更新第三方库时)。 pod —-version 查看当前 pod 版本。 sudo gem uninstall cocoapods （卸载当前的CocoaPods）。 sudo gem install cocoapods -v 0.38.1 （安装 0.38.1 版本的 CocoaPods ）。 关于 CocoaPods 的一些问题总结出现导入头文件问题，未找到 xxx.h Xcode 选择 Target -&gt; Build Settings 菜单，找到 User Header Search Paths 设置项。 新增一个值 ${SRCROOT}，并且选择为 Recursive。 图形化插件 终端中执行： curl -fsSL https://raw.github.com/supermarin/Alcatraz/master/Scripts/install.sh | sh 。 安装完成重启 Xcode 即可， 在 Xcode -&gt; window -&gt; package manger 可以找到 CocoaPods 选项，使用起来简单方便。（Xcode8 导致所有插件失效） 如何编译从 github 上 checkout 下来的一个已包含 CocoPods 类库的项目 删除工程文件夹下的 Podfile、Podfile.lock 及 Pods 文件夹。 删除 xcworkspace 文件。 使用 xcodeproj 文件打开工程，删除 Frameworks 组下的 Pods.xcconfig 及 libPods.a 引用。 在工程设置中的 Build Phases 下删除 Check Pods Manifest.lock 及 Copy Pods Resources 。 安装 CocoaPods 时出现错误ERROR: While executing gem ... (Errno::EPERM) Operation not permitted - /usr/bin/pod 执行 sudo gem install -n /usr/local/bin cocoapods 即可解决。 Mac OS 升级到 10.11 后当 pod 命令失效报错：-bash: pod: command not found。这是你之前有 CocoaPods，但是输入比如 pod update 或者 pod install 之后命令失效，输入：sudo gem install -n /usr/local/bin cocoapods然后在执行命令，就会解决。 执行 pod update 和 pod install 速度比较慢的问题在国内，你有可能就被墙了，所以就不要用 pod update 和 pod install 了，使用：pod update –verbose –no-repo-update 和 pod install –verbose –no-repo-update 来代替。 报错：[!] Unable to add a source with url https//: github.com/CocoaPods/Spece.git named master 如果你是初次初次使用CocoaPods， 可能会出现 Setting up CocoaPods master repo 的提示， 说明 CocoaPods 在将它的信息下载到你的电脑 ~/.cocoapods 里，使用 cd ~/.cocoapods 到该目录里，用 du -sh * 命令来查看文件大小，每隔几分钟查看一次，我的这个目录最终大小是 123M ，就是完成了。 上面的错误就是因为你本地 repo 的问题，你可以尝试使用 pod update 更新，或者可以到网上下载 master 放到 ~/.cocoapods 里面即可。 打开本地目录 ~/.cocoapods，可以看到里面存放的是所有库的podspec 文件，这里面包含了所有可以使用 CocoaPods 管理库的版本和地址等信息，关于 podspec 文件可参考我的另一篇文章 ”使用CocoaPods 制作和关联使用私有库“ 报错： [!] The dependency XXX is not used in any concrete target.需要在 Podfile 文件中指定 target 工程，未指定便会报这个错。12345target 'FMGApp' do pod 'JazzHands' pod 'SSKeychain', '1.2.3' pod 'UMengSocial', '4.2.3'end 持续更新中…]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>CocoaPods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 3D Touch 功能的介绍和实现]]></title>
    <url>%2F2015%2F12%2F11%2F2015%2FiOS-3DTouch-introduction-and-realization%2F</url>
    <content type="text"><![CDATA[3D Touch 是苹果在 2015 年秋季发布会上发布的 iPhone 6S 的新功能，除了类似 Apple Watch、MacBook 触摸板的标准、深压体验之外， iPhone 6s 的触摸屏还将新增一种新层次的维度，实现更多操作体验。 3D Touch 是什么3D Touch 的具体功能3D Touch 是一种可以让你与手机进行互动的全新方式。新的 iPhone 6S 能够感应你按压屏幕的力度。除了轻点、轻扫、双指开合这些熟悉的 Multi‑Touch 手势之外，3D Touch 还带来 Peek 和 Pop，且当你使用 3D Touch 时，iPhone 将回以轻微的触感，让你不仅能够看到按下屏幕的操作效果，还能感觉得到。 具体功能是，用力按一个图标会弹出一层半透明菜单，里面包含了该应用下的一些快捷操作，看起来类似 PC 上的右键。3D Touch 的功能很强大，Peek 和 Pop 让你能够预览所有类型的内容，甚至可对内容进行操作，却不必真的打开它们。例如轻点电话就可以查看最近联系人，按压相机可以快速自拍，按压图片库可以快速浏览大图等。 开发环境和调试设备Apple 不仅推出了 3D Touch 功能，还开放其 API 的调用接口。 开发环境：Xcode7 或以上版本。 调试设备：iOS9 或以上系统版本，iPhone6s 或以上设备。 主要功能模块3D Touch 功能主要分为两大块： 主屏幕 Icon 上的快捷标签。（Home Screen Quick Actions Peek（预览）和 Pop （跳至预览的详细界面） 3D Touch 的实现如何让你的模拟器支持 3D Touch3D Touch的必要条件是 iPhone 6s 或以上、iOS 9 或以上、 Xcode 7 或以上版本，没有 iPhone 6s 的话也没关系，github 上有人提供了这样的一个可以让我们在模拟器上进行 3D Touch 的效果测试的插件，安装和使用方法参见 git 主页里的介绍。SBShortcutMenuSimulator 如何判断设备是否支持 3D Touch123if (self.traitCollection.forceTouchCapability == UIForceTouchCapabilityAvailable) &#123; // 支持 3D Touch&#125; 不能使用判断手机是否为 6S 或 6SP，是因为如果用户在设置 -&gt; 通用 -&gt; 3D Touch 中将该功能关闭的话，同样 forceTouch 是不可用的。另外可在 traitCollectionDidChange: 代理中监听 forceTouchCapability 的变化。 主屏幕按压应用图标展示快捷选项（即 Home Screen Quick Actions）一个应用最多可以有 4 个快捷选项标签，iOS 9 为我们提供了 2 种方式来开发按压应用图标展示快捷选项功能（Home Screen Quick Actions），即动态标签和静态标签。 静态标签在 info.plist 文件中手动加入 UIApplicationShortcutItems 选项。 UIApplicationShortcutItems：数组中的每个元素就是每一个快捷选项标签（最多 4 个）。 UIApplicationShortcutItemTitle：标签的标题（必填） UIApplicationShortcutItemType：标签的唯一标识，用作区分（必填） UIApplicationShortcutItemIconType：标签系统图标的类型，如搜索、定位、分享等，详见 enum UIApplicationShortcutIconType（选填） UIApplicationShortcutItemIconFile：自定义标签图片（可选） UIApplicationShortcutItemSubtitle：标签的副标题（可选） UIApplicationShortcutItemUserInfo：字典信息，可用于传值等（可选） 动态标签在 AppDelegate.m 文件中调用如下方法：1234567891011121314//创建应用图标上的3D touch快捷选项- (void)creatShortcutItem &#123; //创建系统风格的icon UIApplicationShortcutIcon *icon = [UIApplicationShortcutIcon iconWithType:UIApplicationShortcutIconTypeShare]; // 创建自定义图标的icon // UIApplicationShortcutIcon *icon2 = [UIApplicationShortcutIcon iconWithTemplateImageName:@"分享.png"]; //创建快捷选项 UIApplicationShortcutItem * item = [[UIApplicationShortcutItem alloc]initWithType:@"com.mycompany.myapp.share" localizedTitle:@"分享" localizedSubtitle:@"分享副标题" icon:icon userInfo:@&#123;@"key2" : @"value2"&#125;]; //添加到快捷选项数组 [UIApplication sharedApplication].shortcutItems = @[item];&#125; 点击快捷选项标签进入应用的响应主屏幕 icon 上的快捷标签点击进入页面的实现有点类似消息通知的实现方式，需要增加两处代码：首次启动 App （杀死后）和 App 从后台进入到前台启动（未被杀死）。 首次启动的响应：12345678910111213141516171819202122232425262728293031323334353637// App 首次启动的响应方法- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; MainViewController *mainView = [[MainViewController alloc] init]; UINavigationController *mainNavi = [[UINavigationController alloc] initWithRootViewController:mainView]; self.window.rootViewController = mainNavi; [self.window makeKeyAndVisible]; //创建应用图标上的3D touch快捷选项 [self creatShortcutItem]; UIApplicationShortcutItem *shortcutItem = [launchOptions valueForKey:UIApplicationLaunchOptionsShortcutItemKey]; // 如果是从快捷选项标签启动 App，则根据不同标识执行不同操作，然后返回 NO，防止调用 // - (void)application:(UIApplication *)application performActionForShortcutItem:(UIApplicationShortcutItem *)shortcutItem completionHandler:(void (^)(BOOL))completionHandler if (shortcutItem) &#123; //判断设置的快捷选项标签唯一标识，根据不同标识执行不同操作 if([shortcutItem.type isEqualToString:@"com.lewanny.button"])&#123; // 点击第一个按钮 NSLog(@"点击了 -&gt; 第一个按钮"); &#125; else if ([shortcutItem.type isEqualToString:@"com.lewanny.search"]) &#123; // 进入搜索界面 NSLog(@"点击了 -&gt; 搜索按钮"); &#125; else if ([shortcutItem.type isEqualToString:@"com.lewanny.location"]) &#123; // 进入定位界面 NSLog(@"点击了 -&gt; 定位按钮"); &#125;else if ([shortcutItem.type isEqualToString:@"com.lewanny.share"]) &#123; // 进入分享页面 NSLog(@"点击了 -&gt; 分享按钮"); &#125; return NO; &#125; return YES;&#125; 后台启动的响应：123456789101112131415161718192021222324// 如果 App 没被杀死，点开 Touch 后台启动会调用该代理方法- (void)application:(UIApplication *)application performActionForShortcutItem:(UIApplicationShortcutItem *)shortcutItem completionHandler:(void (^)(BOOL))completionHandler &#123; if (shortcutItem) &#123; //判断设置的快捷选项标签唯一标识，根据不同标识执行不同操作 if([shortcutItem.type isEqualToString:@"com.lewanny.button"])&#123; // 点击第一个按钮 NSLog(@"点击了 -&gt; 第一个按钮"); &#125; else if ([shortcutItem.type isEqualToString:@"com.lewanny.search"]) &#123; // 进入搜索界面 NSLog(@"点击了 -&gt; 搜索按钮"); &#125; else if ([shortcutItem.type isEqualToString:@"com.lewanny.location"]) &#123; // 进入定位界面 NSLog(@"点击了 -&gt; 定位按钮"); &#125;else if ([shortcutItem.type isEqualToString:@"com.lewanny.share"]) &#123; // 进入分享页面 NSLog(@"点击了 -&gt; 分享按钮"); &#125; &#125; if (completionHandler) &#123; completionHandler(YES); &#125;&#125; peek（展示预览）和 pop（跳页至预览的界面）的实现peek：当你用力按下屏幕按到一定程度时，系统会弹出一个预览视图，这个过程就称之为 peek。pop：再用力按下去就会展开到预览视图的控制器，这过程就是 pop 。 注册 peek 和 pop首先给 view 注册 3DTouch 的 peek 和 pop 功能。（在需要使用该功能的个页面上注册）1234567// 注册 3D Touch，先判断是否可用if (self.traitCollection.forceTouchCapability == UIForceTouchCapabilityAvailable)&#123; [self registerForPreviewingWithDelegate:self sourceView:self.locationView]; NSLog(@"3D Touch 可用"); &#125;else&#123; NSLog(@"3D Touch 无效");&#125; 继承协议需要继承协议 UIViewControllerPreviewingDelegate 。 代理方法实现 UIViewControllerPreviewingDelegate 的代理方法。123456789101112131415161718192021222324252627// peek 手势弹出的预览视图// previewingContext: 执行 peek 的上下文对象。// location: 按压位置再 souceView 上的点，可以理解为手指在屏幕上的按压点。- (nullable UIViewController *)previewingContext:(id&lt;UIViewControllerPreviewing&gt;)previewingContext viewControllerForLocation:(CGPoint)location &#123; // 获取sourceView 即注册时传入的sourceView，一般为控制器的view UIView *pressView = [previewingContext sourceView]; // 然后判断按压点是否在某个控件的 frame 内， /* 这里有个涉及到坐标系转换的细节问题 如果self.locationView不是sourceView的直接子控件，那么我们需要把point转换到self.locationView的父控件的坐标系中，代码如下： point = [self.locationView.superView convertPoint:point fromView:sourceView]; 若缺少这段代码，你会发现按压位置错乱的bug。 */ // 如果 self.locationView.frame 不包含这个点就直接 return, 不做任何操作 if(!CGRectContainsPoint(self.locationView.frame, location)) return nil; // 否则即触摸点在 self.locationView 上，设置 sourceRect，这个 souceRect 就是当你按压售后浮起来的那个矩形区域，即不被虚化的范围。 CGRect sourceRect = self.locationView.frame; [previewingContext setSourceRect:sourceRect]; // 返回预览界面 TouchViewController *touchVc = [[TouchViewController alloc] init]; return touchVc;&#125; 123456// pop 过程会调用此方法，执行跳转- (void)previewingContext:(id&lt;UIViewControllerPreviewing&gt;)previewingContext commitViewController:(UIViewController *)viewControllerToCommit &#123; // Show 要展示的视图 [self showViewController:viewControllerToCommit sender:self];&#125; 设置预览视图在接下来的预览视图中添加向上滑显示的菜单，即 TouchViewController 的 .m 文件中自定义你要显示的菜单。123456789101112131415161718// 3D Touch 上移显示的视图-(NSArray&lt;id&lt;UIPreviewActionItem&gt;&gt; *)previewActionItems&#123; UIPreviewAction *action1 = [UIPreviewAction actionWithTitle:@"菜单_01" style:UIPreviewActionStyleDefault handler:^(UIPreviewAction * _Nonnull action, UIViewController * _Nonnull previewViewController) &#123; NSLog(@"click -&gt; 菜单_01"); &#125;]; UIPreviewAction *action2 = [UIPreviewAction actionWithTitle:@"菜单_02" style:UIPreviewActionStyleDefault handler:^(UIPreviewAction * _Nonnull action, UIViewController * _Nonnull previewViewController) &#123; NSLog(@"click -&gt; 菜单_02"); &#125;]; UIPreviewAction *action3 = [UIPreviewAction actionWithTitle:@"菜单_03" style:UIPreviewActionStyleDefault handler:^(UIPreviewAction * _Nonnull action, UIViewController * _Nonnull previewViewController) &#123; NSLog(@"click -&gt; 菜单_03"); &#125;]; // 想要显示多个就定义多个 UIPreviewAction NSArray *actions = @[action1,action2,action3]; return actions;&#125; Tableview 中使用 peek 和 pop123456789101112131415161718192021222324252627- (nullable UIViewController *)previewingContext:(id&lt;UIViewControllerPreviewing&gt;)previewingContext viewControllerForLocation:(CGPoint)location &#123; // 获取 sourceView UIView *sourceView = [previewingContext sourceView]; // 通过坐标点获取 indexPath /* 同样如果sourceView != self.tableView的话，也需要转换坐标系 point = [self.tableView convertPoint:point fromView:sourceView]; */ NSIndexPath*indexPath = [self.tableView indexPathForRowAtPoint:location]; // 如果 indexPath 为 nil，则直接返回 nil if(!indexPath) return nil; // 获得当前cell，设置sourceRect UITableViewCell *cell = [self.tableView cellForRowAtIndexPath:indexPath]; CGRect sourceRect = cell.frame; /* 这里同时也涉及到坐标系转换 sourceRect = [self.tableView convertRect:cell.frame toView:sourceView]; */ [previewingContext setSourceRect:sourceRect]; // 返回预览界面 TouchViewController *touchVc = [[TouchViewController alloc] init]; return touchVc;&#125; 3D Touch 压力值的运用直接在需要的 ViewController 的 .m 文件中加入以下方法即可，按压 controller 中的任何视图都会调用这个方法：1234567// 按住移动或压力值改变时的回调-(void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; NSArray *arrayTouch = [touches allObjects]; UITouch *touch = (UITouch *)[arrayTouch lastObject]; // 注意：如果按压的是 UILabel 或 UIImageView，要将其的 userInteractionEnabled 属性设置为YES NSLog(@"move压力 ＝ %f",touch.force);&#125;]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>3D Touch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 上传 ipa 包至 App Store 报错 Error ITMS-90096 Your binary is not optimized for iPhone 5]]></title>
    <url>%2F2015%2F11%2F06%2F2015%2FiOS-upload-appstore-error-90096-solution%2F</url>
    <content type="text"><![CDATA[问题描述向 App Store 提交 ipa 包时报如下错误: 使用 Xcode7 向 App Stor e提交 ipa 包时，提示 ERROR ITMS-90096：”You binary is not optimized for iPhone 5….” 错误。 解决方案解决方案在于对 iPhone5 单独设置 LaunchImage 图片: 把对应的图片放在工程的根目录下。 图片的尺寸需保证为 320*568 大小。 图片的命名为 Default-568.png 。 以上三点为必要条件，然后在工程的 plist 文件中添加 UILaunchimages 数组即可，如下图：]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>AppStore 上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 判断系统版本号的多种方法]]></title>
    <url>%2F2015%2F10%2F04%2F2015%2FiOS-judge-system-version-methods%2F</url>
    <content type="text"><![CDATA[iOS 开发中，有一些启用掉的 API 运行在高版本的系统上可能会无效等问题，在低版本系统上使用新的 API 也是如此，甚至会引起程序的 Crash 。所以此时就需要判断用户设备的版本，根据不同的版本号使用对应的方法来适配不同的系统。 例如以下 NSCalendar 的方法：1234// iOS 8 之前是使用这个方法 currentCalendar 来获取 NSCalendar 对象，如果在 iOS 8 或 iOS 9 上使用就可能会有问题。NSCalendar *calendar = [NSCalendar currentCalendar]; // iOS 8 以后，可以使用下面的方法获取 NSCalendar 对象。NSCalendar *calendar = [NSCalendar calendarWithIdentifier:NSCalendarIdentifierGregorian]; 比较系统版本号获取当前系统版本：1NSString *version = [UIDevice currentDevice].systemVersion; 将版本号 String 转换成 Double 进行比较：12345678NSCalendar *calendar = nil;if (version.doubleValue &gt;= 8.0) &#123; // iOS 系统版本 &gt;= 8.0 calendar = [NSCalendar calendarWithIdentifier:NSCalendarIdentifierGregorian];&#125; else&#123; // iOS 系统版本 &gt; 8.0 calendar = [NSCalendar currentCalendar]; &#125; 比较 Foundation 框架的版本号iOS 系统版本号提升的时候，Foundation 的版本也会同时提高。12345678910111213141516171819202122232425#if TARGET_OS_IPHONE#define NSFoundationVersionNumber_iPhoneOS_2_0 678.24#define NSFoundationVersionNumber_iPhoneOS_2_1 678.26#define NSFoundationVersionNumber_iPhoneOS_2_2 678.29#define NSFoundationVersionNumber_iPhoneOS_3_0 678.47#define NSFoundationVersionNumber_iPhoneOS_3_1 678.51#define NSFoundationVersionNumber_iPhoneOS_3_2 678.60#define NSFoundationVersionNumber_iOS_4_0 751.32#define NSFoundationVersionNumber_iOS_4_1 751.37#define NSFoundationVersionNumber_iOS_4_2 751.49#define NSFoundationVersionNumber_iOS_4_3 751.49#define NSFoundationVersionNumber_iOS_5_0 881.00#define NSFoundationVersionNumber_iOS_5_1 890.10#define NSFoundationVersionNumber_iOS_6_0 992.00#define NSFoundationVersionNumber_iOS_6_1 993.00#define NSFoundationVersionNumber_iOS_7_0 1047.20#define NSFoundationVersionNumber_iOS_7_1 1047.25#define NSFoundationVersionNumber_iOS_8_0 1140.11#define NSFoundationVersionNumber_iOS_8_1 1141.1#define NSFoundationVersionNumber_iOS_8_2 1142.14#define NSFoundationVersionNumber_iOS_8_3 1144.17#define NSFoundationVersionNumber_iOS_8_4 1144.17#define NSFoundationVersionNumber_iOS_8_x_Max 1199#define NSFoundationVersionNumber_iOS_9_0 1240.1#endif 123456if (NSFoundationVersionNumber &gt;= NSFoundationVersionNumber_iOS_8_0) &#123; // iOS 系统版本 &gt;= 8.0 calendar = [NSCalendar calendarWithIdentifier:NSCalendarIdentifierGregorian];&#125; else &#123; calendar = [NSCalendar currentCalendar]; &#125; 通过特定的类来判断例如 UIAlertController 是 iOS 8 以后才有的类：NS_CLASS_AVAILABLE_IOS(8_0)可以通过判断 NSClassFromString(@&quot;UIAlertController&quot;) 是否为 NULL 对象，从而来判断当前系统版本是否大于 8.0 。12NSLog(@"%@,%@",NSClassFromString(@"UIAlertController"), NSClassFromString(@"CustomClass"));打印结果：UIAlertController---UIAlertController, CustomClass---(null) 1234// iOS 系统版本 &gt;= 8.0if (NSClassFromString(@"UIAlertController")) &#123; // do something&#125; 通过特定方法进行判断NS_AVAILABLE(10_10, 8_0)：意为此方法是 iOS 8 之后才出现的，例如下面 NSString 的方法：1- (BOOL)containsString:(NSString *)str NS_AVAILABLE(10_10, 8_0); 123if ([@"" respondsToSelector:@selector(containsString:)]) &#123; // iOS系统版本 &gt;= 8.0&#125;]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>版本号</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 中 Block 的基本语法和使用]]></title>
    <url>%2F2015%2F09%2F24%2F2015%2FiOS-block-basic-grammar-and-usage%2F</url>
    <content type="text"><![CDATA[代码块 Block 是苹果在 iOS4 开始引入的对 C 语言的扩展，用来实现匿名函数的特性。Block 是一种特殊的数据类型，其可以正常定义变量、作为参数、作为返回值。特殊地，Block 还可以保存一段代码，在需要的时候调用。目前 Block 已经广泛应用于 iOS 开发中，常用于 GCD、动画、排序及各类回调。 Block 在我们的实际开发中太常用了，个人觉得很好用，无论是界面传值还是当做参数都十分的灵活。例如 GCD、AFNetworking 的回调等都是用 Block 实现的，且 Apple 官方的很多 API 都由 Delegate 写法换成了 Block 。 Block 是什么？那么，Block 到底是什么呢？用一句话来概括就是带有自动变量的匿名函数。 匿名函数匿名函数顾名思义就是不带名字的函数，C 语言中不允许该类函数的存在，而在 OC 的 Block 中则是可以使用指针来直接调用一个函数的。 自动变量自动变量在 Block 中的具体表现就是截获自动变量。1234567int a = 0;void(^blockLog)() = ^&#123; NSLog(@"Input a = %d", a);&#125;;a = 10;blockLog();// 打印结果：Input a = 0 上面的代码虽然我们在调用 blockLog 前改变了变量 a 的值，但是输出的值还是 blockLog 在编译时 a 的值。所以截获自动变量的概念就是：在Block中会保存变量的值，而不会随变量的值的改变而改变。 我们再来看下面的代码。12345int a = 0;void(^blockLog)() = ^&#123; a = 10; NSLog(@"Input a = %d", a);&#125;; 上面的代码会报错，编译器会提示不能再 Block 中改变变量的值。因为在 Block 截获了变量的瞬间值后就不能再改变改变量的值，如果想在 Block 中改变该变量的值，那么我们需要在变量声明的时候加上 __Block 修饰符。如下：1234567__block int a = 0;void(^blockLog)() = ^&#123; a = 10; NSLog(@"Input a = %d", a);&#125;;blockLog();// 打印结果：Input a = 10 但是下面的情况是允许的：123456NSMutableArray *arrayInsert = [NSMutableArray array];void(^blockLog)() = ^&#123; [arrayInsert addObject:@"Obj"]; NSLog(@"array = %@", arrayInsert);&#125;;blockLog(); 因为我们只是对截获的变量进行了操作，而没有进行赋值，所以对于截获变量，可以进行操作而不可以进行赋值。 还有一点需要注意，在 Block 中不支持对 C 语言数组进行操作。 Block 的语法和分类Block 的语法下面是一个完整的 Block 写法：123^int (NSString *str1, NSString *str2) &#123; return [str1 intValue] + [str2 intValue];&#125; “^” 这个符号用来表示这是一个 Block 。 int 表示返回值。（可省略或 void） (NSString str1, NSString str2) 这个括号中是 Block 的参数，即参数列表，语法和 C 语言类似。（没有时也可省略） Block 变量那么为什么需要 Block 变量？我们可以这样理解，我们可以通过这个 Block 变量来获取 Block 的指针，然后通过这个指针就可以来使用 Block 函数。我们先来看一下如何声明一个 Block 变量：1int (^blockExp)(NSString *str1,NSString *str1); 对照前面的 Block 函数其含义分别为： 返回值 变量名 参数列表 然后我们用上面讲到的 Block 语法来对这 Block 变量进行赋值，我们就可以将这个 Block 变量当作 C 语言函数来使用了。 123456int (^blockExp)(NSString *str1, NSString *str2);blockExp = ^(NSString *str1, NSString *str2) &#123; return [str1 intValue] + [str2 intValue];&#125;;NSLog(@"Result = %d", blockExp(@"1", @"2"));// 打印结果：Result = 3 无参无返的 Block无参数无返回值的 Block 。1234void (^block1)() = ^() &#123; &#125;;block1() 有参无返的 Block无参数无返回值的 Block 。1234void (^block2)(NSString *) = ^(NSString *str) &#123; &#125;;block2(@"Obj"); 有参有返的 Block无参数有返回值的 Block 。12345int (^block3)(int num) = ^(int num) &#123; return num+1;&#125;;NSLog(@"Result = %d", block3(10));// 输出结果：Result = 11 Block 的实际应用Block 结合 typedef 使用在实际使用 Block 的过程中，我们可能需要重复地声明多个相同返回值相同参数列表的 Block 变量，如果总是重复地编写一长串代码来声明变量会非常繁琐，所以我们可以使用 typedef 来定义 Block 类型。123456789// 定义一种无返回值有参数的 Block 类型typedef void (^SayHello)(NSString *str);// 可以像 OC 中声明变量一样使用 Block 类型 SayHello 来声明变量并调用SayHello hello = ^(NSString *saySrr)&#123; NSLog(@"%@", saySrr);&#125;;hello(@"Hello World"); // 打印结果：Hello World Block 作为属性1234// 定义一种有参有返的 Block typedef NSString *(^MyBlock)(int a);// 定义一个 MyBlock 属性@property (nonatomic,copy)MyBlock block; Block 作为函数参数12// 定义一个 Block typedef void (^MyBlock)(UIColor* aColor); 这样我们就可以使用 MyBlock 来表示这个 Block，将 MyBlock 加入到函数参数中来声明一个函数。1234- (void)setMyBlock:(MyBlock)block &#123; block([UIColor redColor]);&#125; 可在任意地方调用这个函数。12345[secondVc setMyBlock:^NSString *(UIColor* aColor) &#123; NSLog(@"%@", aColor); wself.view.backgroundColor = aColor; return @"";&#125;]; 我们平时锁使用的许多回调当中大多都是这样的形式，其较多的就是网络请求回调了，我们只需要调用方法，然后在回调当中就可以对结果进行操作，很多苹果自己写的 API 都是使用了这样的方法。这样做的好处就是形式上十份简洁，当然像这种地方你使用 delegate 肯定也是可以的，但是表现上就没有 Block 那么简洁，使用起来也没有 Block 那么方便。 使用 Block 在页面中反向传值Blcok 是一个匿名函数，同时也是一个指针，那么使用 Block 就可以弥补在 iOS 中函数传递的功能。在页面 B 中定义一个 Block 并声明一个 Block 变量。12345678// 声明部分typedef void(^BlockChange)(NSString *titleStr, UIColor *bgColor);@property(nonatomic, copy)BlockChange blockChange;- (void)setChangeColorBlock:(BlockChange) block;// 实现部分- (void)setChangeColorBlock:(BlockChange) block &#123; self.blockChange = block;&#125; 在页面 A 中的代码。123456SecondViewController *secondVc = [[SecondViewController alloc] init];__weak FirstViewController * wself = self;[secondVc setChangeColorBlock:^(NSString *titleStr, UIColor *bgColor) &#123; wself.view.backgroundColor = bgColor; wself.tabBarItem.title = titleStr;&#125;]; 在页面 B 的任意适当位置调用 block 变量。1self.blockChange(@"传递颜色", [UIColor grayColor]); 这样 @”传递颜色” 和 [UIColor grayColor] 就从界面 B 传到了界面 A 。 注意事项使用 __block 修改局部变量Block 可以访问局部变量，但是不能修改。如果想要修改局部变量，需要使用 __block 来修饰变量。12345__block int multiplier = 7;int (^myBlock)(int) = ^(int num) &#123; multiplier ++;//这样就可以了 return num * multiplier;&#125;; 但是如果局部变量是数组字典或者指针的时候，只 copy 了这个指针，两个指针指向同一个地址，block 只修改指针上的内容。12345NSMutableArray *arrayInsert = [NSMutableArray array];void(^blockLog)() = ^&#123; [arrayInsert addObject:@"Obj"]; NSLog(@"array = %@", arrayInsert);&#125;; 例子中的 arrayInsert 是一个指针，指向一个可数组。在 block 里面，并没有修改这个指针，而是修改了这个指针指向的数组。换句话说，指针保存的是一块内存区域的地址，在block 里，并没有改变这个地址，而是读取出这个地址，然后去操作这块地址空间的内容，这是允许的。 因为声明 block 的时候实际上是把当时的临时变量又复制了一份，在 block 里即使修改了这些复制的变量，也不影响外面的原始变量。即所谓的闭包。但是当变量是一个指针的时候，block里只是复制了一份这个指针，两个指针指向同一个地址。所以，在block里面对指针指向内容做的修改，在block外面也一样生效。 使用 __week 修改局部变量如果在 Block 中使用附有 __strong 修饰符的对象类型自动变量，那么当 Block 从栈复制到堆时，改对象为 Block 所有。这样容易引起循环引用，从而发生内存泄漏。然而我们只需要保证当前控制器也就是 self 在需要释放的时候正确释放就可以。1__weak FirstViewController * wself = self; 我们定义一个 wself 变量并使用 __weak 修饰符，在 Block 代码块中，所有需要 self 的地方都用 wself 来替代。这样就不会增加引用计数，所以 Block 持有 self 对象就不会造成循环引用，从而造成内存泄漏。 注意：在使用 block 前需要对 block 指针做判空处理，如果是MRC的编译环境下，要先 release 掉 block 对象。将 block 赋值为空，是解掉循环引用的重要方法。]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>block</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 简单而实用的动态加载闪屏图方法]]></title>
    <url>%2F2015%2F07%2F17%2F2015%2FiOS-loading-flash-screen-dynamically-metohd%2F</url>
    <content type="text"><![CDATA[iOS 开发中往往有动态更换闪屏图或者在闪屏图后加载广告的需求，如果是在闪屏后加载广告，在闪屏展示对应的广告页面即可。但是如果要动态更新闪屏图启是不可以的，如果要想实现这种效果，只能做出一种假象来，让人感觉你的启动图就是动态获取的。 实现的思路是先把启动图空白或者部分空白，然后用一个 VC 或者 UIimageview 来做动态获取服务器图片然后显示的功能，这个 VC 的界面一定要做的和你的启动页一模一样。然后在第一个 VC 中，设置代码加动画，设置请求下来的启动图什么的就都可以了。 代码如下：1234567891011121314151617181920212223- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; MainViewController *mainVc = [[MainViewController alloc] init]; UINavigationController *navi = [[UINavigationController alloc] initWithRootViewController:mainVc]; self.window.rootViewController = navi; [self.window makeKeyAndVisible]; // 在 window 上放一个 imageView UIImageView *imageView = [[UIImageView alloc]initWithFrame:[UIScreen mainScreen].bounds]; imageView.image = [UIImage imageNamed:@"img_bg-1"]; [self.window addSubview:imageView]; // 执行动画 [UIView animateWithDuration:2 animations:^&#123; // 两秒内图片变大为原来的 1.3 倍 imageView.transform = CGAffineTransformMakeScale(1.2,1.2); imageView.alpha = 0; &#125; completion:^(BOOL finished) &#123; // 动画结束，移除 imageView，呈现主界面 [imageView removeFromSuperview]; &#125;]; return YES;&#125;]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>动态闪屏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 第三方库 FMDB 详解]]></title>
    <url>%2F2015%2F06%2F23%2F2015%2FiOS-thirdlib-FMDB-detailed-annotation%2F</url>
    <content type="text"><![CDATA[iOS 中原生的 SQLite API 在进行数据存储的时候，需要使用 C 语言中的函数，操作比较麻烦。于是，就出现了一系列将 SQLite API 进行封装的库，例如 FMDB、PlausibleDatabase 和 qlitepersistentobjects 等。 FMDB 简介什么是 FMDBFMDB 是一款简洁、易用的封装库。因此，在这里推荐使用第三方框架 FMDB，它是对 libsqlite3 框架的封装，用起来的步骤与 SQLite 使用类似，并且它对于多线程的并发操作进行了处理，所以也是线程安全的。 FMDB 的优缺点优点： 对多线程的并发操作进行处理，所以是线程安全的（重要特性之一）。 以 OC 的方式封装了 SQLite 的 C 语言 API，使用起来简洁、高效，没有原来的一大堆晦涩难懂、影响开发效率的 C 语句，更加面向对象。 FMDB 是轻量级的框架，灵活易用。 缺点： 因为它是 OC 的封装的，只能在 iOS 开发的时候使用，所以在实现跨平台操作的时候存在局限性。 FMDB 框架中的重要类 FMDatabase：一个 FMDatabase 对象就代表一个单独的 SQLite 数据库（注意并不是表），用来执行 SQL 语句。 FMResultSet：使用 FMDatabase 执行查询后的结果集。 FMDatabaseQueue：用于在多线程中执行多个查询或更新，线程安全的。 FMDB 的详细使用步骤准备步骤 在工程中导入 FMDB，可以选择手动下载导入 GitHub-FMDB 或使用 CocoaPods 导入。 导入 libsqlite3.0 框架或导入 libsqlite3 框架（而这本质一致，libsqlite3.0 指向 libsqlite3）。 在需要用到 FMDB 的控制器（或模型）地方导入头文件 import FMDatabase.h 。本地的 .sqlite 的查看，非常推荐火狐浏览器中的插件 SQLite Manager 。 创建一个继承于 NSObject 的 Student 类，用来进行数据的增删改查。 1234567#import &lt;Foundation/Foundation.h&gt;@interface Student : NSObject@property (nonatomic, assign) int num; // 学号@property (nonatomic, copy) NSString *name; // 名字@property (nonatomic, copy) NSString *sex; // 性别@property (nonatomic, assign) int age; // 年龄@end 数据库的创建12345678910111213141516171819@interface MainViewController () &#123; FMDatabase *_db; // FMDB 对象 NSString *_docPath; // 沙盒（数据库）路径&#125;@end// 1. 获取文件路径_docPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject]; NSLog(@"文件路径：%@", _docPath); // 2. 数据文件名称NSString *fileName = [_docPath stringByAppendingPathComponent:@"student.sqlite"]; // 3. 获取数据库_db = [FMDatabase databaseWithPath:fileName];if ([_db open]) &#123; NSLog(@"打开数据库成功");&#125; else &#123; NSLog(@"打开数据库失败");&#125; 然后可以打开 _docPath 的路径，可以看到名为 student.sqlite 的数据库已经创建好了。 数据表的创建1234567// 创建表格BOOL result = [_db executeUpdate:@"CREATE TABLE IF NOT EXISTS table_student (id integer PRIMARY KEY AUTOINCREMENT, name text NOT NULL, age integer NOT NULL, sex text NOT NULL);"];if (result) &#123; NSLog(@"创建数据表成功");&#125; else &#123; NSLog(@"创建数据表失败");&#125; 使用火狐浏览器的 SQLite Manager 插件打开 student.sqlite 可以看到table_student 表已经被创建好了。 增加数据12345678910// 插入数据NSString *name = [NSString stringWithFormat:@"王胖子"];int age = 36;NSString *sex = @"男";BOOL resurtInsert = [_db executeUpdate:@"INSERT INTO table_student (name, age, sex) VALUES (?,?,?)",name,@(age),sex];if (resurtInsert) &#123; NSLog(@"插入成功");&#125; else &#123; NSLog(@"插入失败");&#125; 删除数据1234567// 1.不确定的参数用？来占位 （后面参数必须是oc对象,需要将int包装成OC对象）// int idNum = 1;// BOOL result = [_db executeUpdate:@"DELETE FROM t_student WHERE id = ?",@(idNum)];BOOL result = [_db executeUpdate:@"DELETE FROM table_student WHERE name = ?",@"王胖子"];if (result) &#123; NSLog(@"删除成功");&#125; 修改数据123456NSString *oldName = @"王胖子";NSString *newNAme = @"无邪";BOOL result = [_db executeUpdate:@"UPDATE table_student set name = ? WHERE name = ?", newNAme, oldName];if (result) &#123; NSLog(@"修改成功");&#125; 查询数据123456789// FMResultSet *resultSet = [_db executeQuery:@"SELECT * FROM table_student"];FMResultSet *resultSet = [_db executeQuery:@"SELECT * FROM table_student WHERE id &lt; ?", @(4)];while ([resultSet next]) &#123; int idNum = [resultSet intForColumn:@"id"]; NSString *name = [resultSet objectForColumn:@"name"]; int age = [resultSet intForColumn:@"age"]; NSString *sex = [resultSet objectForColumn:@"sex"]; NSLog(@"学号：%@ 姓名：%@ 年龄：%@ 性别：%@",@(idNum),name,@(age),sex);&#125; 表的删除1234BOOL result = [_db executeUpdate:@"DROP TABLE IF EXISTS table_student"];if (result) &#123; NSLog(@"删除成功");&#125; 执行之后，刷新 SQLite，可以看到 table_student 表已经被删除了。]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>FMDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 如何选择和获取设备的唯一标识符]]></title>
    <url>%2F2015%2F04%2F14%2F2015%2FiOS-select-acquire-device-unique-identifying%2F</url>
    <content type="text"><![CDATA[iOS 开发中常常需要将一些用户的使用日志等上传的服务器，方便反馈查询错误。要识别用户，就要选择一个标识符，通过这个标识符来识别这个用户的设备，这个标识符要能够保证一个设备上返回的值是一样的，并且在其他设备上不会出现相同的值，那么该如何获取这个到 iOS 设备的标识符。 概述在 iOS 7 之前，曾经有过很多方法来识别用户的设备，从最原始的设备 UDID、mac 地址，到被各广告统计平台广泛使用的开源方案 OpenUDID 。 但 iOS 7 之后，Apple 更加注重保护用户隐私，随着 AppStore 开始拒绝接受使用 UDID 的应用，到 mac 地址在在所有设备上都返回相同的值，再到 iOS7 上对剪贴板的限制，导致 OpenUDID 无法被不同应用共享相同的值，注定了上面提到的这些 id 们不得不退出历史的舞台。 那么我们该用什么来追踪和识别用户？ idfa: 适用于对外：例如广告推广，换量等跨应用的用户追踪等。 idfv: 适用于对内：例如分析用户在应用内的行为等。 被弃用的方法UDID设备唯一标识符（Unique Device Identifier）之前被各种国内外统计平台，应用开发商广泛使用，后 Apple 从 2013 年 05 月 01 日起拒绝接受使用 UDID 的应用。 Mac 地址每一个网卡都有一个唯一的标识，即 Mac 地址，用来标识一个手机是绰绰有余，也有一些开源的方案也用到了它，国内 UMTrack 等也用它作为过主 id，随着 iOS 7 返回同样的值后，不得不被弃用。 OpenUDID在 Apple 拒绝 UDID 后，OpenUDID 作为独立于 Apple 的开源方案，被广大的开发者所接受，各大统计广告平台都从 UDID 等方案切换到 OpenUDID 的方案，但同样由于 iOS 7 对剪贴板的限制，导致同一个设备上应用间，无法再共享一个 OpenUDID，即 OpenUDID 作为设备唯一标识的能力被大大削弱。 DeviceTokenDeviceToken 是推送用的唯一标识，但是用户如果没开推送，或者拒绝了推送，这个便没有了。 推荐的方法idfa 全名：advertisingIdentifier 示例代码： 12#import &lt;AdSupport/AdSupport.h&gt;NSString *adIdStr = [[[ASIdentifierManager sharedManager] advertisingIdentifier] UUIDString]; 适用于：iOS 6.0 之后，适用于对外，例如广告推广，换量等跨应用的用户追踪等。 说明：直译就是广告id， 在同一个设备上的所有 App 都会取到相同的值，是苹果专门给各广告提供商用来追踪用户而设的，用户可以在 设置|隐私|广告追踪 里重置此 id 的值，或限制此 id 的使用，故此 id有 可能会取不到值，但好在 Apple 默认是允许追踪的，而且一般用户都不知道有这么个设置，所以基本上用来监测推广效果，是戳戳有余了。 注意：由于 idfa 会出现取不到的情况，故绝不可以作为业务分析的主 id，来识别用户。 idfv 全名：identifierForVendor 示例代码： 1NSString *idfv = [[[UIDevice currentDevice] identifierForVendor] UUIDString]; 适用于：iOS 6.0 之后，适用于对内，例如分析用户在应用内的行为等。 说明：顾名思义，是给 Vendor 标识用户用的，每个设备在所属同一个 Vender 的应用里，都有相同的值。其中的 Vender 是指应用提供商，但准确点说，是通过 BundleID 的 DNS 转的前两部分进行匹配，如果相同就是同一个 Vender，例如对于 com.somecompany.appone 和 com.somecompany.apptwo 这两个 BundleID 来说，就属于同一个 Vender，共享同一个 idfv 的值。和 idfa 不同的是，idfv 的值是一定能取到的，所以非常适合于作为内部用户行为分析的主 id，来标识用户，替代 OpenUDID。 注意：如果用户将属于此 Vender 的所有 App 卸载，则 idfv 的值会被重置，即再重装此 Vender 的 App，idfv 的值和之前不同。 总之，Apple 越来越注重用户的隐私，也越来越去掌控一些关于隐私的设置，所以跟随 Apple 的政策，使用 idfv 和 idfa 作为设备的唯一标识符为最佳。]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>设备标识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS NSTimer 注意事项及 GCD 定时器的使用]]></title>
    <url>%2F2015%2F02%2F19%2F2015%2FiOS-NSTimer-notice-and-GCDTimer-usage%2F</url>
    <content type="text"><![CDATA[NSTimer 定时器 NSTimer 的创建和使用123456// 创建和开始NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(beginCount) userInfo:nil repeats:YES]; 注意：Timer 自动启动。repeats 参数表示是否循环使用定时器，NO 表示只调用一次。将计数器的 repeats 设置为 YES 的时候，self 的引用计数会加 1 。因此可能会导致 self 不能 release，所以，必须在 viewWillAppear 的时候，将计数器 timer 关闭，否则可能会导致内存泄露。 NSTimer的关闭123// 关闭[timer invalidate];timer = nil; 注意：一定要赋值为空，这样才是真的释放。 NSTimer的暂停和继续1234// 暂停[timer setFireDate:[NSDate distantFuture]];// 继续[timer setFireDate:[NSDate date]]; NSTimer的弊端和注意下事项 必须保证有一个活跃的 runloop，子线程的 runloop 是默认关闭的，这时如果不激活 runloop，performSelector 和 scheduledTimerWithTimeInterval 的调用将是无效的。 NSTimer 的创建与撤销必须在同一个线程操作、performSelector 的创建与撤销必须在同一个线程操作。 内存管理有潜在泄露的风险。 如果不是通过 invalidate 来关闭是无法停止的，还有持有 self，造成对象无法释放。 所以推荐用 dispatch 的 timer。 GCD 定时器 GCD 定时器的创建和执行1234567891011121314151617- (void)startGCDTimer&#123; // GCD定时器 static dispatch_source_t _timer; NSTimeInterval period = 1.0; //设置时间间隔 dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue); dispatch_source_set_timer(_timer, dispatch_walltime(NULL, 0), period * NSEC_PER_SEC, 0); //每秒执行 // 事件回调 dispatch_source_set_event_handler(_timer, ^&#123; // 在主线程中执行 dispatch_async(dispatch_get_main_queue(), ^&#123; NSLog(@"Do Count"); &#125;); &#125;); dispatch_resume(_timer);&#125; 注意：dispatch_source_t 必须是全局或 static 变量。 GCD 定时器的停止1234567-(void) stopGCDTimer&#123; // 停止 if(_timer)&#123; dispatch_source_cancel(_timer); _timer = nil; &#125;&#125; GCD 定时器的暂停和继续123456789101112-(void) pauseGCDTimer&#123; // 暂停 if(_timer)&#123; dispatch_suspend(_timer); &#125;&#125;-(void) resumeGCDTimer&#123; // 继续 if(_timer)&#123; dispatch_resume(_timer); &#125;&#125;]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>NSTimer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 开发笔记之 UISlider]]></title>
    <url>%2F2014%2F11%2F09%2F2014%2FiOS-objc-development-note-UISlider%2F</url>
    <content type="text"><![CDATA[改变 UISlider 滑道的高度12345// 控制 slider 的宽和高，这个方法才是真正的改变 slider 滑道的高- (CGRect)trackRectForBounds:(CGRect)bounds&#123; return CGRectMake(0, 0, CGRectGetWidth(self.frame), _adjustHeight);&#125; 注意：此方法直接调用是无效的，要重写一个继承于 UISlider 的子类，在子类中重写下面的方法才有效。1-(CGRect)trackRectForBounds:(CGRect)bounds; 改变 UISlider 滑块的大小可以使用 setThumbImage 方法，滑块的大小会随设置的图片尺寸改变。123[_progressSlider setThumbImage:[UIImage imageNamed:@"ic_slider"] scaleToSize:CGSizeMake(10, 10) forState:UIControlStateNormal]; 改变 UIImage 尺寸的方法，可加在 UIImage 的 Category 方法中。1234567891011121314/* 对原来的图片的大小进行处理 @param image 要处理的图片 @param size 处理过图片的大小 */+ (UIImage *)imageNamed:(NSString *)imagestr scaleToSize:(CGSize)size&#123; UIImage *image = [UIImage imageNamed:imagestr]; UIGraphicsBeginImageContext(size); [image drawInRect:CGRectMake(0,0, size.width, size.height)]; UIImage *scaleImage=UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return scaleImage;&#125; 增加触控范围在 UISlider 的拖动手势不灵敏的时候此方法有效。同样需要子类继承 UISlider，然后重写下面的方法。1234567- (CGRect)thumbRectForBounds:(CGRect)bounds trackRect:(CGRect)rect value:(float)value&#123; // y 轴方向改变手势范围 rect.origin.y = rect.origin.y - 10; rect.size.height = rect.size.height + 20; return CGRectInset([super thumbRectForBounds:bounds trackRect:rect value:value], 10, 10);&#125; 监听 Slider 滑动停止当监听 Slider 值变化的时候，如果直接在 slider 上绑定事件，则改变一次就需要需要处理一次。这种在某些情况下是不合理的。解决方法如下。1234// 先将 slider 绑定一个事件[_progressSlider addTarget:self action:@selector(sliderValueChanged:) forControlEvents:UIControlEventValueChanged];// 将其属性设置成 NO_progressSlider.continuous = NO; 这样就只会在停止滑动的时候发送一个 valuechange 的通知，在 sliderValueChanged 方法中实现你需要进行的操作即可。 持续更新中……]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>UISlider</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 开发 OC 拓展类的几种方式]]></title>
    <url>%2F2014%2F10%2F03%2F2014%2FiOS-objc-class-extension-methods%2F</url>
    <content type="text"><![CDATA[继承继承：子类 subClass作用：可以通过类的继承来增添父类的属性和方法。写法：在 .h 文件中1@interface Student : Person 类目类目：Category，也叫分类、类别。作用：可以增添父类的方法，但是不能定义变量。多用于不知道源码的情况下，对父类进行拓展。例如用来拓展系统类。写法：在 .h 和 .m 中，文件名为 “父类名+分类名” 格式。在 @interface 和 @implementation 后 “父类名(分类名)” 。123// NSString+autoResize@interface NSString (autoResize)@implementation NSString (autoResize) 延展延展：Extension作用：定义私有方法，可以隐藏不对外公布的方法，多用于隐藏一些中间步骤的方法。写法：在 .m 文件中的 @implementation 前实现。12345@interface Person() &#123; NSString * _age;&#125; - (void)logAge;@end 协议协议方法：protocol作用：可以实现类似多继承的方法，一个类遵守多个协议。写法：协议只有 .h 文件，定义了方法。123456@required //默认是必须实现的 - (void)method1; - (void)method2; @optional //可以选择实现 - (void)method3;]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
  </entry>
</search>
