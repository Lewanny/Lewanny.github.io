<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hexo Next 主题的优化]]></title>
    <url>%2F2018%2F02%2F28%2FHexo-next-theme-optimization%2F</url>
    <content type="text"><![CDATA[关于 Next 主题的优化，如设置主题样式、字体、头像、第三方统计、评论、分享等在 NexT 使用文档 里都有极详细的介绍，这里不一一介绍了。只记录一些文档中没有提及的点。 第三方推荐搜索：Local Search 简单方便，安装即可使用。统计：不蒜子统计，简单易用推荐使用。评论：来必力评论，目前好像也只有这个可用了，之前还用过不蒜子评论和网易云跟帖。 侧边栏社交小图标设置打开主题配置文件 _config.yml 搜索 social:，在 图标库 找自己喜欢的小图标，并将名字复制在对应的 || 后，保存即可： 1234social: GitHub: https://github.com/Lewanny || github 微博: https://weibo.com/u/2951067307 || weibo 简书: https://www.jianshu.com/users/f0040a970739 || heartbeat 添加 about 页面进入到博客根目录下，执行以下命令： $ hexo new page &quot;about&quot; 完成后会在 /source/about 目录下生成一个 index.md 文件。打开 index.md 文件，在 data 下添加 type: &quot;about&quot;，然后编辑自己想要展示的内容即可。（注意将主题配置文件中的 menu: about 页面打开）。 添加网易云音乐播放使用 iframe 标签播放即可。 &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; width=&quot;300&quot; height=&quot;86&quot; src=&quot;https://music.163.com/outchain/player?type=2&amp;id=5253801&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt; // 到网易云中复制即可 如果想放在侧栏里面播放，将代码 加入到 hexo/themes/next/layout/_macro 目录中的 sidebar.swig 文件中即可。位置如下： 设置网站的 Favicon 图标准备一个常见格式名(如.jpg、.png等)的图片作为备选 favicon，选择一个 favicon 制作网站完成制作，例如：比特虫。 如下修改主题配置文件即可：12345favicon: small: /images/favicon_16x16.ico medium: /images/favicon_32x32.ico apple_touch_icon: /images/favicon_128x128.ico safari_pinned_tab: /images/favicon_128x128.ico 添加 “high 一下”绑定独立域名购买域名在你的域名注册提供商那里配置DNS解析，获取GitHub的IP地址点击，进入source目录下，添加CNAME文件 $ cd source/ $ touch CNAME $ vim CNAME # 输入你的域名 $ git add CNAME $ git commit -m &quot;add CNAME&quot; ####]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>主题优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Hexo 搭建个人博客并部署到 Github Page]]></title>
    <url>%2F2018%2F02%2F26%2FHexo-build-yourown-blog-with-hexo%2F</url>
    <content type="text"><![CDATA[Hexo 是一个快速、简洁且高效的博客框架。而 Github 是一个免费的代码托管工具，利用 Github Page 可以免费创建一个静态网站。下面将介绍如何使用 Hexo 和 Github，在 mac 环境下搭建静态博客。 由于前段时间电脑突然故障，导致所有本地数据全部丢失，所以不得不重新把个人博客搭起来。还好当时把博客分别部署到了 Coding 和 Github，省去了一些麻烦事，只是 md 文件都要重新写一遍了。这里记录下相关的过程。有备无患。 Hexo 环境配置Node.js用来生成静态页面，可到 Node.js 官网 下载推荐版本，默认配置一路安装即可。 Git用来将本地 Hexo 内容提交到 Github 上。Xcode 自带 Git。如果没有 Xcode 可以参考 Git 官网 下载安装。 安装 HexoNode.js 和 Git 都安装好后就可以正式安装 Hexo 了，终端执行如下命令： $ sudo npm install -g hexo sudo:linux 系统管理指令 -g:全局安装 初始化 Hexo，终端 cd 到一个你选定的目录，执行 hexo init 命令： $ hexo init blog blog 是你建立的文件夹名称。 cd 到 blog 文件夹下，执行如下命令，安装 npm： $ npm install 执行如下命令，开启 Hexo 服务器（结束为 control+c）： $ hexo s 此时，浏览器中打开网址 http://localhost:4000，如果能看到如下页面，Hexo 本地初始化即完成： 关联到 Github添加 ssh key 到 Github检查 SSH keys 是否存在 Github执行如下命令，检查 SSH keys 是否存在。如果有文件 id_rsa.pub 或 id_dsa.pub ，则直接进入步骤 1.3 将 SSH key 添加到 Github 中，否则进入下一步生成 SSH key。 $ ls -al ~/.ssh 生成新的 ssh key执行如下命令生成 public/private rsa key pair，注意将 your_email@example.com 换成你自己注册 Github 的邮箱地址。、 $ ssh-keygen -t rsa -C &quot;your_email@example.com&quot; 接下来会提示输入密码路径，按 3 次回车，密码为空。最后会在相应路径下（~/.ssh/id_rsa.pub）生成 d_rsa 和 id_rsa.pub 两个文件。 将 ssh key 添加到 Github 中Finder 前往文件夹 ~/.ssh/id_rsa.pub 打开 id_rsa.pub 文件，里面的信息即为 SSH key，将这些信息复制到 Github 的 Add SSH key 页面即可。 进入Github –&gt; Settings –&gt; SSH keys –&gt; add SSH key，Title 任意，将复制的内容粘贴到 Key 里，点击 Add key 按钮即可。 创建仓库登录 Github 帐号，新建仓库，命名必须为 用户名.github.io 固定写法，如Lewanny.github.io,如下图所示： 本地的 blog 文件夹下内容为： 配置文件打开 _config.yml 文件，里面是博客的主体配置项，找到 deploy: 配置，修改如下：1234deploy: type: git repository: https://github.com/Lewanny/Lewanny.github.io.git branch: master 注意：在配置所有的 _config.yml 文件时（包括 theme）时，在所有的冒号 : 后边都要加一个空格，否则执行 hexo 命令会报错。 部署文件生成静态页面命令在 blog 文件夹目录下执行生成静态页面命令： $ hexo g // 或者：hexo generate 此时若出现如下报错：1 ERROR Local hexo not found in ~/blog 2 ERROR Try runing: &#39;npm install hexo --save&#39;则执行命令：npm install hexo --save 配置命令再执行配置命令： $ hexo d // 或者：hexo deploy 若执行命令 hexo deploy 仍然报错：ERROR Deployer not found: git。则执行如下命令来安装 hexo-deployer-git： npm install --save hexo-deployer-git 再次执行 hexo generate 和 hexo deploy 命令 (或 hexo d -g，即部署前先生成静态界面) 即可完成 Github 关联。此时，浏览器中打开网址 https://lewanny.github.io（注意将 username 替换）能看到和打开 http://localhost:4000 时一样的页面。 安装 Theme可以到 Hexo 官网主题页 去搜寻自己喜欢的 theme。这里以 hexo-theme-next 为例，Next 官网。 终端 cd 到 blog 目录下执行如下命令： $ git clone https://github.com/iissnan/hexo-theme-next themes/next 将 blog 目录下 _config.yml 里 theme 的名称 landscape 修改为 next 即可。 终端 cd 到 blog 目录下执行如下命令(每次部署文章的步骤)：12$ hexo clean // 清除缓存文件 (db.json) 和已生成的静态文件 (public)$ hexo d -g // 生成缓存和静态文件并重新部署到服务器 至于更改 theme 内容，比如名称，描述，头像等去修改 blog/_config.yml 文件和 blog/themes/next/_config.yml 文件中对应的属性名称即可， 不要忘记冒号:后加空格。NexT 使用文档里有极详细的介绍。 发表文章终端 cd 到 blog 文件夹下，执行如下命令新建文章： hexo new &quot;postName&quot; // postName为文章名字 名为 postName.md 的文件会建在目录 /blog/source/_posts 下。你当然可以用 vim 来编辑文章，这里推荐使用 MacDown。 文章编辑完成后，终端 cd 到 blog 文件夹下，执行如下命令来发布：12hexo generate // 生成静态页面hexo deploy // 将文章部署到 Github // 或 hexo d -g 至此，使用 Hexo 搭建个人博客并部署到 GitHub 就基本完成了。后面会陆续更新出如何绑定独立域名、next 主题的优化和功能配置、同时部署博客到 GitHub 和 Coding、提交文章到百度谷歌收录、备份博客等（防止悲剧重演…）。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 第三方库 FMDB 详解]]></title>
    <url>%2F2015%2F06%2F23%2FiOS-thirdlib-FMDB-detailed-annotation%2F</url>
    <content type="text"><![CDATA[iOS 中原生的 SQLite API 在进行数据存储的时候，需要使用 C 语言中的函数，操作比较麻烦。于是，就出现了一系列将 SQLite API 进行封装的库，例如 FMDB、PlausibleDatabase 和 qlitepersistentobjects 等。 FMDB 简介什么是 FMDBFMDB 是一款简洁、易用的封装库。因此，在这里推荐使用第三方框架 FMDB，它是对 libsqlite3 框架的封装，用起来的步骤与 SQLite 使用类似，并且它对于多线程的并发操作进行了处理，所以也是线程安全的。 FMDB 的优缺点优点： 对多线程的并发操作进行处理，所以是线程安全的（重要特性之一）。 以 OC 的方式封装了 SQLite 的 C 语言 API，使用起来简洁、高效，没有原来的一大堆晦涩难懂、影响开发效率的 C 语句，更加面向对象。 FMDB 是轻量级的框架，灵活易用。 缺点： 因为它是 OC 的封装的，只能在 iOS 开发的时候使用，所以在实现跨平台操作的时候存在局限性。 FMDB 框架中的重要类 FMDatabase：一个 FMDatabase 对象就代表一个单独的 SQLite 数据库（注意并不是表），用来执行 SQL 语句。 FMResultSet：使用 FMDatabase 执行查询后的结果集。 FMDatabaseQueue：用于在多线程中执行多个查询或更新，线程安全的。 FMDB 的详细使用步骤准备步骤 在工程中导入 FMDB，可以选择手动下载导入 GitHub-FMDB 或使用 CocoaPods 导入。 导入 libsqlite3.0 框架或导入 libsqlite3 框架（而这本质一致，libsqlite3.0 指向 libsqlite3）。 在需要用到 FMDB 的控制器（或模型）地方导入头文件 import FMDatabase.h 。本地的 .sqlite 的查看，非常推荐火狐浏览器中的插件 SQLite Manager 。 创建一个继承于 NSObject 的 Student 类，用来进行数据的增删改查。 1234567#import &lt;Foundation/Foundation.h&gt;@interface Student : NSObject@property (nonatomic, assign) int num; // 学号@property (nonatomic, copy) NSString *name; // 名字@property (nonatomic, copy) NSString *sex; // 性别@property (nonatomic, assign) int age; // 年龄@end 数据库的创建12345678910111213141516171819@interface MainViewController () &#123; FMDatabase *_db; // FMDB 对象 NSString *_docPath; // 沙盒（数据库）路径&#125;@end// 1. 获取文件路径_docPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject]; NSLog(@"文件路径：%@", _docPath); // 2. 数据文件名称NSString *fileName = [_docPath stringByAppendingPathComponent:@"student.sqlite"]; // 3. 获取数据库_db = [FMDatabase databaseWithPath:fileName];if ([_db open]) &#123; NSLog(@"打开数据库成功");&#125; else &#123; NSLog(@"打开数据库失败");&#125; 然后可以打开 _docPath 的路径，可以看到名为 student.sqlite 的数据库已经创建好了。 数据表的创建1234567// 创建表格BOOL result = [_db executeUpdate:@"CREATE TABLE IF NOT EXISTS table_student (id integer PRIMARY KEY AUTOINCREMENT, name text NOT NULL, age integer NOT NULL, sex text NOT NULL);"];if (result) &#123; NSLog(@"创建数据表成功");&#125; else &#123; NSLog(@"创建数据表失败");&#125; 使用火狐浏览器的 SQLite Manager 插件打开 student.sqlite 可以看到table_student 表已经被创建好了。 增加数据12345678910// 插入数据NSString *name = [NSString stringWithFormat:@"王胖子"];int age = 36;NSString *sex = @"男";BOOL resurtInsert = [_db executeUpdate:@"INSERT INTO table_student (name, age, sex) VALUES (?,?,?)",name,@(age),sex];if (resurtInsert) &#123; NSLog(@"插入成功");&#125; else &#123; NSLog(@"插入失败");&#125; 删除数据1234567// 1.不确定的参数用？来占位 （后面参数必须是oc对象,需要将int包装成OC对象）// int idNum = 1;// BOOL result = [_db executeUpdate:@"DELETE FROM t_student WHERE id = ?",@(idNum)];BOOL result = [_db executeUpdate:@"DELETE FROM table_student WHERE name = ?",@"王胖子"];if (result) &#123; NSLog(@"删除成功");&#125; 修改数据123456NSString *oldName = @"王胖子";NSString *newNAme = @"无邪";BOOL result = [_db executeUpdate:@"UPDATE table_student set name = ? WHERE name = ?", newNAme, oldName];if (result) &#123; NSLog(@"修改成功");&#125; 查询数据123456789// FMResultSet *resultSet = [_db executeQuery:@"SELECT * FROM table_student"];FMResultSet *resultSet = [_db executeQuery:@"SELECT * FROM table_student WHERE id &lt; ?", @(4)];while ([resultSet next]) &#123; int idNum = [resultSet intForColumn:@"id"]; NSString *name = [resultSet objectForColumn:@"name"]; int age = [resultSet intForColumn:@"age"]; NSString *sex = [resultSet objectForColumn:@"sex"]; NSLog(@"学号：%@ 姓名：%@ 年龄：%@ 性别：%@",@(idNum),name,@(age),sex);&#125; 表的删除1234BOOL result = [_db executeUpdate:@"DROP TABLE IF EXISTS table_student"];if (result) &#123; NSLog(@"删除成功");&#125; 执行之后，刷新 SQLite，可以看到 table_student 表已经被删除了]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>FMDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 如何选择和获取设备的唯一标识符]]></title>
    <url>%2F2015%2F04%2F14%2F2015%2FiOS-select-acquire-device-unique-identifying%2F</url>
    <content type="text"><![CDATA[iOS 开发中常常需要将一些用户的使用日志等上传的服务器，方便反馈查询错误。要识别用户，就要选择一个标识符，通过这个标识符来识别这个用户的设备，这个标识符要能够保证一个设备上返回的值是一样的，并且在其他设备上不会出现相同的值，那么该如何获取这个到 iOS 设备的标识符。 概述在 iOS 7 之前，曾经有过很多方法来识别用户的设备，从最原始的设备 UDID、mac 地址，到被各广告统计平台广泛使用的开源方案 OpenUDID 。 但 iOS 7 之后，Apple 更加注重保护用户隐私，随着 AppStore 开始拒绝接受使用 UDID 的应用，到 mac 地址在在所有设备上都返回相同的值，再到 iOS7 上对剪贴板的限制，导致 OpenUDID 无法被不同应用共享相同的值，注定了上面提到的这些 id 们不得不退出历史的舞台。 那么我们该用什么来追踪和识别用户？ idfa: 适用于对外：例如广告推广，换量等跨应用的用户追踪等。 idfv: 适用于对内：例如分析用户在应用内的行为等。 被弃用的方法UDID设备唯一标识符（Unique Device Identifier）之前被各种国内外统计平台，应用开发商广泛使用，后 Apple 从 2013 年 05 月 01 日起拒绝接受使用 UDID 的应用。 Mac 地址每一个网卡都有一个唯一的标识，即 Mac 地址，用来标识一个手机是绰绰有余，也有一些开源的方案也用到了它，国内 UMTrack 等也用它作为过主 id，随着 iOS 7 返回同样的值后，不得不被弃用。 OpenUDID在 Apple 拒绝 UDID 后，OpenUDID 作为独立于 Apple 的开源方案，被广大的开发者所接受，各大统计广告平台都从 UDID 等方案切换到 OpenUDID 的方案，但同样由于 iOS 7 对剪贴板的限制，导致同一个设备上应用间，无法再共享一个 OpenUDID，即 OpenUDID 作为设备唯一标识的能力被大大削弱。 DeviceTokenDeviceToken 是推送用的唯一标识，但是用户如果没开推送，或者拒绝了推送，这个便没有了。 推荐的方法idfa 全名：advertisingIdentifier 示例代码： 12#import &lt;AdSupport/AdSupport.h&gt;NSString *adIdStr = [[[ASIdentifierManager sharedManager] advertisingIdentifier] UUIDString]; 适用于：iOS 6.0 之后，适用于对外，例如广告推广，换量等跨应用的用户追踪等。 说明：直译就是广告id， 在同一个设备上的所有 App 都会取到相同的值，是苹果专门给各广告提供商用来追踪用户而设的，用户可以在 设置|隐私|广告追踪 里重置此 id 的值，或限制此 id 的使用，故此 id有 可能会取不到值，但好在 Apple 默认是允许追踪的，而且一般用户都不知道有这么个设置，所以基本上用来监测推广效果，是戳戳有余了。 注意：由于 idfa 会出现取不到的情况，故绝不可以作为业务分析的主 id，来识别用户。 idfv 全名：identifierForVendor 示例代码： 1NSString *idfv = [[[UIDevice currentDevice] identifierForVendor] UUIDString]; 适用于：iOS 6.0 之后，适用于对内，例如分析用户在应用内的行为等。 说明：顾名思义，是给 Vendor 标识用户用的，每个设备在所属同一个 Vender 的应用里，都有相同的值。其中的 Vender 是指应用提供商，但准确点说，是通过 BundleID 的 DNS 转的前两部分进行匹配，如果相同就是同一个 Vender，例如对于 com.somecompany.appone 和 com.somecompany.apptwo 这两个 BundleID 来说，就属于同一个 Vender，共享同一个 idfv 的值。和 idfa 不同的是，idfv 的值是一定能取到的，所以非常适合于作为内部用户行为分析的主 id，来标识用户，替代 OpenUDID。 注意：如果用户将属于此 Vender 的所有 App 卸载，则 idfv 的值会被重置，即再重装此 Vender 的 App，idfv 的值和之前不同。 总之，Apple 越来越注重用户的隐私，也越来越去掌控一些关于隐私的设置，所以跟随 Apple 的政策，使用 idfv 和 idfa 作为设备的唯一标识符为最佳。]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>设备标识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS NSTimer 注意事项及 GCD 定时器的使用]]></title>
    <url>%2F2015%2F02%2F19%2F2015%2FiOS-NSTimer-notice-and-GCDTimer-usage%2F</url>
    <content type="text"><![CDATA[NSTimer 定时器 NSTimer 的创建和使用123456// 创建和开始NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(beginCount) userInfo:nil repeats:YES]; 注意：Timer 自动启动。repeats 参数表示是否循环使用定时器，NO 表示只调用一次。将计数器的 repeats 设置为 YES 的时候，self 的引用计数会加 1 。因此可能会导致 self 不能 release，所以，必须在 viewWillAppear 的时候，将计数器 timer 关闭，否则可能会导致内存泄露。 NSTimer的关闭123// 关闭[timer invalidate];timer = nil; 注意：一定要赋值为空，这样才是真的释放。 NSTimer的暂停和继续1234// 暂停[timer setFireDate:[NSDate distantFuture]];// 继续[timer setFireDate:[NSDate date]]; NSTimer的弊端和注意下事项 必须保证有一个活跃的 runloop，子线程的 runloop 是默认关闭的，这时如果不激活 runloop，performSelector 和 scheduledTimerWithTimeInterval 的调用将是无效的。 NSTimer 的创建与撤销必须在同一个线程操作、performSelector 的创建与撤销必须在同一个线程操作。 内存管理有潜在泄露的风险。 如果不是通过 invalidate 来关闭是无法停止的，还有持有 self，造成对象无法释放。 所以推荐用 dispatch 的 timer。 GCD 定时器 GCD 定时器的创建和执行1234567891011121314151617- (void)startGCDTimer&#123; // GCD定时器 static dispatch_source_t _timer; NSTimeInterval period = 1.0; //设置时间间隔 dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue); dispatch_source_set_timer(_timer, dispatch_walltime(NULL, 0), period * NSEC_PER_SEC, 0); //每秒执行 // 事件回调 dispatch_source_set_event_handler(_timer, ^&#123; // 在主线程中执行 dispatch_async(dispatch_get_main_queue(), ^&#123; NSLog(@"Do Count"); &#125;); &#125;); dispatch_resume(_timer);&#125; 注意：dispatch_source_t 必须是全局或 static 变量。 GCD 定时器的停止1234567-(void) stopGCDTimer&#123; // 停止 if(_timer)&#123; dispatch_source_cancel(_timer); _timer = nil; &#125;&#125; GCD 定时器的暂停和继续123456789101112-(void) pauseGCDTimer&#123; // 暂停 if(_timer)&#123; dispatch_suspend(_timer); &#125;&#125;-(void) resumeGCDTimer&#123; // 继续 if(_timer)&#123; dispatch_resume(_timer); &#125;&#125;]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>NSTimer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 开发笔记之 UISlider]]></title>
    <url>%2F2014%2F11%2F09%2F2014%2FiOS-objc-development-note-UISlider%2F</url>
    <content type="text"><![CDATA[改变 UISlider 滑道的高度12345// 控制 slider 的宽和高，这个方法才是真正的改变 slider 滑道的高- (CGRect)trackRectForBounds:(CGRect)bounds&#123; return CGRectMake(0, 0, CGRectGetWidth(self.frame), _adjustHeight);&#125; 注意：此方法直接调用是无效的，要重写一个继承于 UISlider 的子类，在子类中重写下面的方法才有效。1-(CGRect)trackRectForBounds:(CGRect)bounds; 改变 UISlider 滑块的大小可以使用 setThumbImage 方法，滑块的大小会随设置的图片尺寸改变。123[_progressSlider setThumbImage:[UIImage imageNamed:@"ic_slider"] scaleToSize:CGSizeMake(10, 10) forState:UIControlStateNormal]; 改变 UIImage 尺寸的方法，可加在 UIImage 的 Category 方法中。1234567891011121314/* 对原来的图片的大小进行处理 @param image 要处理的图片 @param size 处理过图片的大小 */+ (UIImage *)imageNamed:(NSString *)imagestr scaleToSize:(CGSize)size&#123; UIImage *image = [UIImage imageNamed:imagestr]; UIGraphicsBeginImageContext(size); [image drawInRect:CGRectMake(0,0, size.width, size.height)]; UIImage *scaleImage=UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return scaleImage;&#125; 增加触控范围在 UISlider 的拖动手势不灵敏的时候此方法有效。同样需要子类继承 UISlider，然后重写下面的方法。1234567- (CGRect)thumbRectForBounds:(CGRect)bounds trackRect:(CGRect)rect value:(float)value&#123; // y 轴方向改变手势范围 rect.origin.y = rect.origin.y - 10; rect.size.height = rect.size.height + 20; return CGRectInset([super thumbRectForBounds:bounds trackRect:rect value:value], 10, 10);&#125; 监听 Slider 滑动停止当监听 Slider 值变化的时候，如果直接在 slider 上绑定事件，则改变一次就需要需要处理一次。这种在某些情况下是不合理的。解决方法如下。1234// 先将 slider 绑定一个事件[_progressSlider addTarget:self action:@selector(sliderValueChanged:) forControlEvents:UIControlEventValueChanged];// 将其属性设置成 NO_progressSlider.continuous = NO; 这样就只会在停止滑动的时候发送一个 valuechange 的通知，在 sliderValueChanged 方法中实现你需要进行的操作即可。 持续更新中……]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>UISlider</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 开发 OC 拓展类的几种方式]]></title>
    <url>%2F2014%2F10%2F03%2F2014%2FiOS-objc-class-extension-methods%2F</url>
    <content type="text"><![CDATA[继承继承：子类 subClass作用：可以通过类的继承来增添父类的属性和方法。写法：在 .h 文件中1@interface Student : Person 类目类目：Category，也叫分类、类别。作用：可以增添父类的方法，但是不能定义变量。多用于不知道源码的情况下，对父类进行拓展。例如用来拓展系统类。写法：在 .h 和 .m 中，文件名为 “父类名+分类名” 格式。在 @interface 和 @implementation 后 “父类名(分类名)” 。123// NSString+autoResize@interface NSString (autoResize)@implementation NSString (autoResize) 延展延展：Extension作用：定义私有方法，可以隐藏不对外公布的方法，多用于隐藏一些中间步骤的方法。写法：在 .m 文件中的 @implementation 前实现。12345@interface Person() &#123; NSString * _age;&#125; - (void)logAge;@end 协议协议方法：protocol作用：可以实现类似多继承的方法，一个类遵守多个协议。写法：协议只有 .h 文件，定义了方法。123456@required //默认是必须实现的 - (void)method1; - (void)method2; @optional //可以选择实现 - (void)method3;]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
  </entry>
</search>
